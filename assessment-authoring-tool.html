<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assessment Question Management | Bryt</title>
    
    <!-- Markdown Parser (marked.js) -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- LaTeX Math Rendering (KaTeX) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --border: #e5e7eb;
            --bg-subtle: #f9fafb;
            --text-main: #1f2937;
            --text-muted: #6b7280;
            --success: #16a34a;
            --warning: #f59e0b;
            --danger: #ef4444;
            --json-bg: #1e1e1e;
            --json-fg: #d4d4d4;
            --nav-bg: #1e293b;
            --nav-text: #94a3b8;
            --nav-active: #fff;
            --nav-active-bg: #334155;
        }

        * { box-sizing: border-box; outline: none; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; min-height: 100vh; color: var(--text-main); background: #f8fafc; }

        /* BRYT SIDEBAR */
        .bryt-sidebar {
            width: 220px;
            background: linear-gradient(180deg, #3b82f6 0%, #1e40af 100%);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 100;
        }

        .bryt-sidebar-header {
            padding: 1.5rem;
            position: relative;
        }

        .bryt-sidebar-header::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 120px;
            height: 80px;
            background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, transparent 50%);
            clip-path: polygon(100% 0, 0 0, 100% 100%);
        }

        .bryt-logo {
            font-size: 2rem;
            font-weight: 700;
            color: white;
            font-style: italic;
            letter-spacing: -1px;
        }

        .bryt-logo::before {
            content: 'ðŸŽ“';
            margin-right: 0.25rem;
        }

        .bryt-nav-section {
            padding: 0 0.75rem;
            margin-bottom: 1rem;
        }

        .bryt-nav-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.25rem;
        }

        .bryt-nav-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.65rem 0.75rem;
            color: rgba(255,255,255,0.85);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            border-radius: 6px;
            transition: all 0.15s;
            cursor: pointer;
        }

        .bryt-nav-item:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .bryt-nav-item.active {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .bryt-nav-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        /* MAIN CONTENT WRAPPER */
        .main-wrapper {
            flex: 1;
            margin-left: 220px;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* BRYT HEADER */
        .bryt-header {
            background: linear-gradient(135deg, #3b82f6 0%, #1e40af 60%, #1e3a8a 100%);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .bryt-header::before {
            content: '';
            position: absolute;
            top: -50px;
            left: -50px;
            width: 200px;
            height: 200px;
            background: rgba(255,255,255,0.08);
            transform: rotate(45deg);
        }

        .bryt-header::after {
            content: '';
            position: absolute;
            top: -30px;
            left: 80px;
            width: 150px;
            height: 150px;
            background: rgba(255,255,255,0.05);
            transform: rotate(45deg);
        }

        .bryt-page-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: white;
            position: relative;
            z-index: 1;
        }

        .bryt-header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
            position: relative;
            z-index: 1;
        }

        .bryt-user-avatar {
            width: 36px;
            height: 36px;
            background: #a78bfa;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
        }

        /* TOOL CONTENT AREA */
        .tool-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: white;
        }

        /* HORIZONTAL TAB NAVIGATION */
        .tab-navigation {
            display: flex;
            align-items: center;
            background: white;
            border-bottom: 1px solid var(--border);
            padding: 0 1.5rem;
            flex-shrink: 0;
        }
        .nav-tab {
            padding: 1rem 1.25rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-muted);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.15s;
            white-space: nowrap;
        }
        .nav-tab:hover {
            color: var(--text-main);
        }
        .nav-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        /* APP CONTENT AREA */
        .app-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

        /* CONTENT HEADER */
        .content-header {
            border-bottom: 1px solid var(--border);
            padding: 0 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: white;
            height: 50px;
            flex-shrink: 0;
        }
        .header-brand { display: flex; align-items: center; gap: 1rem; }
        .header-title { font-weight: 600; font-size: 0.95rem; color: var(--text-main); }
        .header-meta { font-size: 0.85rem; color: var(--text-muted); padding-left: 1rem; border-left: 1px solid var(--border); }
        .badge-mode { padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; }
        .badge-import { background: #dbeafe; color: #1e40af; border: 1px solid #93c5fd; }
        .badge-library { background: #f3f4f6; color: #374151; border: 1px solid #d1d5db; }
        
        .actions { display: flex; gap: 0.5rem; align-items: center; }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid var(--border);
            background: white;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .btn:hover { background: var(--bg-subtle); border-color: #d1d5db; }
        .btn-primary { background: var(--primary); color: white; border-color: var(--primary); }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-sm { padding: 0.25rem 0.5rem; font-size: 0.75rem; }
        .btn-icon { padding: 0.4rem; }

        /* Workflow Step Buttons */
        .workflow-step {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        .workflow-step .btn {
            padding-left: 2.25rem;
            position: relative;
        }
        .step-badge {
            position: absolute;
            left: 0.5rem;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            background: #e5e7eb;
            color: #6b7280;
            font-size: 0.7rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1;
        }
        .workflow-step.completed .step-badge {
            background: #10b981;
            color: white;
        }
        .workflow-step.active .step-badge {
            background: var(--primary);
            color: white;
            animation: pulse-badge 2s infinite;
        }
        .workflow-step.completed .step-badge::after {
            content: 'âœ“';
            font-size: 0.65rem;
        }
        .workflow-step.completed .step-badge span { display: none; }
        
        /* Active step glow */
        .workflow-step.active .btn {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
            border-color: var(--primary);
        }
        
        /* Connector arrows between steps */
        .workflow-connector {
            display: flex;
            align-items: center;
            color: #d1d5db;
            font-size: 1rem;
            transition: color 0.3s ease;
            margin: 0 0.25rem;
        }
        .workflow-connector.active {
            color: var(--primary);
        }
        .workflow-connector.completed {
            color: #10b981;
        }
        
        /* Animations */
        @keyframes pulse-badge {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
            50% { transform: scale(1.1); box-shadow: 0 0 0 6px rgba(59, 130, 246, 0); }
        }
        @keyframes step-complete {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .workflow-step.just-completed .step-badge {
            animation: step-complete 0.4s ease;
        }
        
        /* Disabled/pending state - not clickable */
        .workflow-step.pending .btn {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
        }
        .workflow-step.pending .btn:hover {
            background: white;
            border-color: var(--border);
        }
        
        /* Completed state - not clickable (already done) */
        .workflow-step.completed .btn {
            opacity: 0.7;
            pointer-events: none;
            cursor: default;
            background: #f0fdf4;
            border-color: #86efac;
        }
        
        /* Native disabled state */
        .workflow-step .btn:disabled {
            cursor: not-allowed;
        }
        
        /* Skip button */
        .btn-skip {
            padding: 0.35rem 0.6rem;
            font-size: 0.75rem;
            font-weight: 500;
            color: #6b7280;
            background: transparent;
            border: 1px dashed #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: 0.35rem;
        }
        .btn-skip:hover:not(:disabled) {
            color: var(--primary);
            border-color: var(--primary);
            background: rgba(59, 130, 246, 0.05);
        }
        .btn-skip:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .workflow-step.completed .btn-skip,
        .workflow-step.pending .btn-skip {
            display: none;
        }
        .workflow-step.active .btn-skip {
            display: inline-block;
        }

        /* WORKSPACE LAYOUT */
        .workspace { display: flex; flex: 1; overflow: hidden; }
        
        /* PANEL (Question List View) */
        .panel {
            width: 320px;
            border-right: 1px solid var(--border);
            background: #fff;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        /* Panel Modules (Switchable) */
        .panel-module { display: none; flex-direction: column; height: 100%; }
        .panel-module.active { display: flex; }

        .panel-filter {
            padding: 0.75rem;
            background: var(--bg-subtle);
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .panel-search {
            padding: 0.75rem;
            background: var(--bg-subtle);
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .search-row { display: flex; gap: 0.5rem; }
        .search-select {
            flex: 1;
            padding: 0.35rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.75rem;
            background: white;
        }
        .fetch-btn {
            width: 100%;
            background: var(--text-main);
            color: white;
            border: none;
            padding: 0.4rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
        }
        .fetch-btn:hover { background: black; }

        .panel-header-status {
            padding: 0.4rem 0.75rem;
            background: #f3f4f6;
            border-bottom: 1px solid var(--border);
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
        }

        .q-list { overflow-y: auto; flex: 1; }
        
        .q-item {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.1s;
            position: relative;
        }
        .q-item:hover { background: #f8fafc; }
        .q-item.active { background: #eff6ff; border-left: 4px solid var(--primary); padding-left: calc(1.25rem - 4px); }
        
        .q-item-header { display: flex; justify-content: space-between; margin-bottom: 0.25rem; align-items: center; }
        .q-id { font-size: 0.75rem; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
        
        .q-location { font-size: 0.7rem; color: var(--primary); font-weight: 600; text-transform: uppercase; margin-bottom: 4px; letter-spacing: 0.02em; }

        .q-preview { font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-main); font-weight: 500; }
        
        .status-indicator { font-size: 0.7rem; font-weight: 600; display: flex; align-items: center; gap: 5px; margin-top: 6px;}
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .valid { color: var(--success); } .valid .dot { background: var(--success); }
        .pending { color: var(--warning); } .pending .dot { background: var(--warning); }

        /* EDITOR (Detail View) */
        .editor { flex: 1; background: #f3f4f6; overflow-y: auto; padding: 2rem; display: none; } /* Hidden by default */
        .editor.active { display: block; }
        
        .editor-card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 100px);
            min-height: 600px;
        }
        
        .card-header {
            padding: 0;
            border-bottom: 1px solid var(--border);
            background: #fff;
            border-radius: 8px 8px 0 0;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .header-top { padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; }
        
        .meta-group { display: flex; gap: 1rem; align-items: center; }
        .meta-item { display: flex; flex-direction: column; }
        
        .card-tabs { display: flex; border-top: 1px solid var(--border); background: var(--bg-subtle); }
        .tab-btn {
            flex: 1;
            padding: 0.75rem;
            text-align: center;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-muted);
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        .tab-btn:hover { background: #f3f4f6; }
        .tab-btn.active { background: white; color: var(--primary); border-bottom-color: var(--primary); }

        .card-body { padding: 0; flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        
        /* EDIT VIEW CONTAINER */
        .edit-view-container { display: none; flex: 1; flex-direction: column; overflow: hidden; }
        .edit-view-container.active { display: flex; }
        
        /* TOOLBAR */
        .editor-toolbar {
            background: var(--bg-subtle);
            padding: 0.5rem 2rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .toolbar-left, .toolbar-right { display: flex; gap: 1rem; align-items: center; }
        .toolbar-group { display: flex; align-items: center; gap: 0.5rem; padding-right: 1rem; border-right: 1px solid var(--border); }
        .toolbar-group:last-child { border-right: none; }
        .toolbar-label { font-size: 0.7rem; font-weight: 700; color: var(--text-muted); text-transform: uppercase; margin-right: 0.5rem; }

        /* Sub-View Toggle */
        .view-toggle { display: flex; background: #e5e7eb; border-radius: 6px; padding: 2px; }
        .view-toggle-btn {
            padding: 4px 12px; font-size: 0.75rem; font-weight: 600; border-radius: 4px; cursor: pointer; border: none; background: transparent; color: var(--text-muted);
        }
        .view-toggle-btn.active { background: white; color: var(--text-main); box-shadow: 0 1px 2px rgba(0,0,0,0.1); }

        /* GRAPHICAL SUB-VIEW */
        .graphical-view { padding: 2rem; overflow-y: auto; overflow-x: hidden; flex: 1; display: block; }

        /* JSON SUB-VIEW */
        .json-view { display: none; flex: 1; flex-direction: column; background: var(--json-bg); position: relative; height: 100%; }
        .json-view.active { display: flex; }
        .json-editor {
            flex: 1; width: 100%; height: 100%; border: none; padding: 1.5rem;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace; font-size: 0.9rem;
            background: var(--json-bg); color: var(--json-fg); resize: none; outline: none; line-height: 1.5;
            box-sizing: border-box;
        }
        .json-footer {
            padding: 0.5rem 1.5rem; background: #2d2d2d; border-top: 1px solid #333; color: #888; font-size: 0.75rem;
            display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; font-family: sans-serif;
        }

        /* PREVIEW VIEW */
        .preview-view-container { 
            padding: 2rem; background: #525659; display: none; flex: 1; justify-content: center; overflow-y: auto; overflow-x: hidden;
        }
        .preview-view-container.active { display: flex; }
        
        .a4-page {
            width: 210mm; min-height: 297mm; background: white; padding: 12mm;
            box-shadow: 0 0 10px rgba(0,0,0,0.3); font-family: "Times New Roman", serif; font-size: 11pt; line-height: 1.4; color: #000;
            text-align: left;
        }
        
        .a4-pages-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* CONTENT STYLES */
        .p-q-block { margin-bottom: 1.5rem; text-align: justify; }
        
        /* Print styles */
        @media print {
            .preview-view-container {
                padding: 0;
                background: white;
            }
            .a4-page {
                box-shadow: none;
                margin: 0;
                padding: 15mm;
                width: 100%;
                min-height: auto;
            }
        }
        .p-q-header { display: grid; grid-template-columns: 1fr auto; align-items: start; gap: 1rem; margin-bottom: 0.5rem; }
        .p-q-content { flex: 1; }
        .p-q-num { font-weight: bold; margin-right: 0.5rem; }
        .p-q-marks { font-size: 10pt; font-weight: bold; white-space: nowrap; padding-top: 0.25rem; }
        
        .p-stimulus { padding: 0.75rem 0; margin-bottom: 1rem; text-align: justify; }
        .p-word-bank { 
            background: white; 
            padding: 0.75rem 1rem; 
            border: 2px dashed #666; 
            border-radius: 8px; 
            margin: 1rem auto; 
            font-style: normal; 
            font-size: 11pt; 
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center; 
            gap: 1.5rem 2rem;
            width: 80%;
        }
        .p-word-bank-item { white-space: nowrap; }
        
        /* Groups for sorting/classification */
        .p-groups-container { display: flex; gap: 1rem; margin: 1rem 0; flex-wrap: wrap; }
        .p-group-box { flex: 1; min-width: 120px; border: 1px solid #000; }
        .p-group-header { background: #f3f4f6; padding: 0.5rem; font-weight: bold; text-align: center; border-bottom: 1px solid #000; }
        .p-group-body { min-height: 80px; padding: 0.5rem; }
        .p-group-line { border-bottom: 1px solid #ccc; margin: 0.75rem 0.5rem; }
        
        /* Pairs for match_columns */
        .p-pairs-container { display: inline-flex; gap: 1.5rem; margin: 1rem 0; }
        .p-pairs-wrapper { width: 80%; margin: 0 auto; text-align: center; }
        .p-pairs-column { min-width: 50px; display: flex; flex-direction: column; flex: 0 0 auto; }
        .p-pairs-header { font-weight: bold; text-align: left; margin-bottom: 0.5rem; font-size: 10pt; padding-left: 0.75rem; }
        .p-pairs-item { padding: 0.4rem 0.75rem; margin-bottom: 0.5rem; border: 1px solid #000; background: white; text-align: left; white-space: nowrap; }
        .p-pairs-item-id { font-weight: bold; margin-right: 0.5rem; }
        
        /* Math (KaTeX) and Markdown styles */
        .katex-display { margin: 0.5rem 0; text-align: center; }
        .katex { font-size: 1.1em; }
        strong, b { font-weight: 600; }
        em, i { font-style: italic; }
        code { background: #f3f4f6; padding: 0.1em 0.3em; border-radius: 3px; font-family: monospace; font-size: 0.9em; }
        
        /* Items to sort */
        .p-items-box { margin-top: 1rem; padding: 0.75rem; border: 1px dashed #999; }
        .p-items-label { font-weight: bold; font-size: 10pt; margin-bottom: 0.5rem; }
        .p-items-list { display: flex; flex-wrap: wrap; gap: 0.75rem; }
        .p-item-chip { padding: 0.25rem 0.75rem; border: 1px solid #000; background: white; }
        
        /* Table styles for stimulus tables */
        .p-table { width: 100%; border-collapse: collapse; margin: 0.75rem 0; font-style: normal; font-size: 10pt; }
        .p-table th, .p-table td { border: 1px solid #d1d5db; padding: 0.5rem 0.75rem; text-align: left; }
        .p-table th { background: #f3f4f6; font-weight: 600; }
        .p-table tbody tr:nth-child(even) { background: #fafafa; }
        
        .p-sub-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
        .p-sub-item { margin-bottom: 0.75rem; text-align: justify; padding-left: 1.5rem; display: flex; align-items: flex-start; }
        .p-sub-label { font-weight: bold; margin-right: 0.5rem; flex-shrink: 0; }
        
        /* TABLE type styles (v4.3 - simple grid with empty cells) */
        .p-table-container { display: flex; justify-content: center; margin: 1rem 0; width: 100%; }
        .p-table-grid { border-collapse: collapse; width: 80%; }
        .p-table-grid th, .p-table-grid td { border: 1px solid #d1d5db; padding: 0.5rem; text-align: center; vertical-align: middle; min-width: 40px; height: 36px; }
        .p-table-grid th { background: #f3f4f6; font-weight: 600; font-size: 0.9em; }
        .p-table-grid td { background: white; }
        .p-table-grid .row-header { background: #f9fafb; font-weight: 500; text-align: left; }
        
        .p-asset { margin: 0.5rem auto; text-align: center; }
        .p-asset img { max-width: 100%; max-height: 200px; border: 1px solid #ccc; display: block; margin: 0 auto; }
        .p-asset-placeholder { display: block; border: 1px dashed #9ca3af; background: #f9fafb; padding: 1.5rem 1rem; margin: 0.75rem auto; color: #6b7280; font-family: sans-serif; font-size: 0.8rem; text-align: center; border-radius: 6px; width: fit-content; }
        
        /* Resizable image container (v4.8) */
        .p-asset-resizable {
            position: relative;
            display: block;
            margin: 0.5rem auto;
            width: fit-content;
            text-align: center;
        }
        .p-asset-resizable img {
            display: block;
            border: 2px solid transparent;
            transition: border-color 0.2s;
            cursor: default;
        }
        .p-asset-resizable:hover img {
            border-color: #3b82f6;
        }
        /* During resize, prevent layout shifts by fixing container dimensions */
        .p-asset-resizable.resizing {
            /* Container size is fixed during resize to prevent text reflow */
        }
        .p-asset-resizable .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        .p-asset-resizable:hover .resize-handle {
            opacity: 1;
        }
        .p-asset-resizable .resize-handle-se {
            right: -6px;
            bottom: -6px;
            cursor: se-resize;
        }
        .p-asset-resizable .resize-handle-e {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            cursor: e-resize;
        }
        .p-asset-resizable .resize-handle-s {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }
        .p-asset-resizable .size-tooltip {
            position: absolute;
            bottom: -24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.75);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 12;
        }
        .p-asset-resizable.resizing .size-tooltip {
            opacity: 1;
        }
        .p-asset-resizable .reset-size-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ef4444;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            font-size: 12px;
            line-height: 14px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 11;
        }
        .p-asset-resizable:hover .reset-size-btn {
            opacity: 1;
        }
        .p-asset-resizable .reset-size-btn:hover {
            background: #dc2626;
        }

        /* Grid layout for preview sections (text left, media right) */
        .p-section-grid { display: grid; grid-template-columns: 1fr auto; gap: 1rem; align-items: start; }
        .p-section-grid .p-section-text { flex: 1; text-align: left; }
        .p-section-grid .p-section-media { display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-end; max-width: 200px; }
        .p-section-grid .p-section-media .p-asset { margin: 0; }
        .p-section-grid .p-section-media .p-asset img { max-width: 180px; max-height: 150px; }
        
        /* Vertical layout (default - text above media) */
        .p-section-stack { display: flex; flex-direction: column; text-align: left; }
        .p-section-stack .p-section-text { text-align: left; }
        .p-section-stack .p-section-media { display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; margin-top: 0.5rem; }
        
        /* Options grid layout in preview */
        .p-options { margin-top: 0.5rem; }
        .p-options-stack .p-option-item { display: block; margin-bottom: 0.25rem; }
        .p-options-grid .p-option-item { display: grid; grid-template-columns: 1fr auto; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; }
        .p-options-grid .p-option-media { max-width: 100px; }
        .p-options-grid .p-option-media img { max-width: 80px; max-height: 60px; }

        /* FORM CONTROLS */
        .content-section { margin-bottom: 2rem; }
        .input-bare { width: 100%; border: 1px solid transparent; padding: 0.5rem; border-radius: 4px; font-family: inherit; font-size: inherit; color: inherit; background: transparent; resize: none; transition: all 0.2s; }
        .input-bare:hover { background: #f9fafb; border-color: #e5e7eb; }
        .input-bare:focus { background: white; border-color: var(--primary); box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1); }
        .prompt-input { font-size: 1.1rem; font-weight: 500; min-height: 3rem; }
        .sub-input { font-size: 0.95rem; min-height: 2.5rem; }
        
        .sub-questions-wrapper { display: flex; flex-direction: column; gap: 1rem; }
        .sub-questions-wrapper.layout-horizontal { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }

        .sub-question-card { background: white; border: 1px solid var(--border); border-radius: 6px; padding: 1rem; position: relative; transition: box-shadow 0.2s; }
        .sub-question-card:focus-within { border-color: var(--primary); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        
        /* Sub-question layout modes */
        .sq-content-stack { display: flex; flex-direction: column; gap: 0.5rem; }
        .sq-content-grid { display: grid; grid-template-columns: 1fr auto; gap: 1rem; align-items: start; }
        .sq-text-area { flex: 1; min-width: 0; }
        .sq-media-area { display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-end; max-width: 200px; }
        .sq-media-area .asset-item-compact { margin: 0; }
        
        /* Layout toggle buttons */
        .layout-toggle-group { 
            display: inline-flex; 
            border: 1px solid var(--border); 
            border-radius: 4px; 
            overflow: hidden;
            background: #f3f4f6;
        }
        .layout-toggle-btn {
            padding: 2px 6px;
            font-size: 0.7rem;
            border: none;
            background: transparent;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.15s;
        }
        .layout-toggle-btn:hover { background: #e5e7eb; }
        .layout-toggle-btn.active { 
            background: var(--primary); 
            color: white; 
        }
        
        .sub-q-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .sub-id-badge { background: #eff6ff; color: var(--primary); font-weight: 700; font-size: 0.8rem; padding: 2px 8px; border-radius: 12px; }
        
        .toggle-wrapper { display: flex; align-items: center; gap: 8px; font-size: 0.75rem; color: var(--text-muted); cursor: pointer; }
        .toggle-input { display: none; }
        .toggle-track { width: 32px; height: 18px; background: #e5e7eb; border-radius: 9px; position: relative; transition: background 0.2s; }
        .toggle-thumb { width: 14px; height: 14px; background: white; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: transform 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .toggle-input:checked + .toggle-track { background: var(--primary); }
        .toggle-input:checked + .toggle-track .toggle-thumb { transform: translateX(14px); }
        .sub-marks-input { width: 80px; padding: 2px 6px; font-size: 0.8rem; border: 1px solid var(--border); border-radius: 4px; text-align: right; display: none; }
        .sub-marks-input.visible { display: block; }
        
        .options-editor { margin-top: 0.5rem; padding: 0.5rem; background: #f9fafb; border-radius: 4px; border: 1px solid #e5e7eb; }
        .option-row { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem; }
        .option-radio { width: 14px; height: 14px; border: 1px solid #ccc; border-radius: 50%; background: white; }
        .option-input { flex: 1; padding: 0.25rem 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.85rem; }

        .asset-container { margin: 0.5rem 0; }
        .asset-item { display: flex; align-items: flex-start; gap: 1rem; background: #f8fafc; border: 1px solid var(--border); padding: 0.75rem; border-radius: 6px; margin-bottom: 0.5rem; }
        .asset-preview { width: 80px; height: 80px; background: #e2e8f0; border-radius: 4px; object-fit: cover; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; overflow: hidden; }
        .asset-preview img { width: 100%; height: 100%; object-fit: cover; }
        .asset-details { flex: 1; }
        .asset-prompt-input { width: 100%; font-size: 0.8rem; color: #4b5563; font-family: monospace; border: 1px solid #e5e7eb; padding: 4px; border-radius: 4px; margin-bottom: 4px;}
        
        /* Compact asset item (when image is present) */
        .asset-item-compact { display: inline-block; margin-right: 0.5rem; margin-bottom: 0.5rem; vertical-align: top; }
        .asset-image-container { 
            position: relative; 
            display: inline-block;
            border-radius: 6px;
            overflow: hidden;
            border: 2px solid var(--success);
            resize: both;
            min-width: 60px;
            min-height: 60px;
            max-width: 400px;
            max-height: 400px;
        }
        .asset-image-container img { 
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #f8fafc;
        }
        /* Resize handle indicator */
        .asset-image-container::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, transparent 50%, var(--success) 50%);
            border-radius: 0 0 4px 0;
            pointer-events: none;
            opacity: 0.7;
        }
        .asset-hover-controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .asset-image-container:hover .asset-hover-controls { opacity: 1; }
        .asset-hover-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            background: white;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s;
        }
        .asset-hover-btn:hover { transform: scale(1.1); }
        .asset-hover-btn.delete-btn { background: #fee2e2; color: #dc2626; }
        
        .empty-state { text-align: center; color: var(--text-muted); margin-top: 20%; }
        #file-input, #image-upload-input { display: none; }

        /* ADD SECTION BUTTONS */
        .add-sections-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 1rem;
            background: #f0f9ff;
            border: 1px dashed #93c5fd;
            border-radius: 6px;
            margin-bottom: 1.5rem;
        }
        .add-section-btn {
            padding: 0.4rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            border: 1px solid #93c5fd;
            background: white;
            color: #1d4ed8;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .add-section-btn:hover { background: #dbeafe; }
        .add-section-btn.disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
        .add-section-label { font-size: 0.7rem; font-weight: 700; color: #1d4ed8; text-transform: uppercase; width: 100%; margin-bottom: 0.25rem; }

        /* SECTION HEADERS WITH REMOVE BUTTON */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .section-label {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        .remove-section-btn {
            font-size: 0.7rem;
            padding: 2px 8px;
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fecaca;
            border-radius: 4px;
            cursor: pointer;
        }
        .remove-section-btn:hover { background: #fecaca; }

        /* OPTIONS EDITOR (Main Level) */
        .options-section {
            background: white;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        .options-section .section-label { color: var(--text-muted); }
        .option-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            background: white;
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
        }
        .option-item .option-id {
            font-size: 0.7rem;
            font-weight: 700;
            color: #6d28d9;
            min-width: 50px;
        }
        .option-item input { flex: 1; padding: 0.4rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.85rem; }
        .option-actions { display: flex; gap: 0.25rem; }
        .option-actions button { padding: 4px 8px; font-size: 0.7rem; }

        /* RUBRIC EDITOR */
        .rubric-section {
            background: #fef3c7;
            padding: 1rem;
            border-radius: 6px;
            border: 1px dashed #fcd34d;
        }
        .rubric-section .section-label { color: #92400e; }
        .rubric-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        .rubric-field { display: flex; flex-direction: column; gap: 0.25rem; }
        .rubric-field label { font-size: 0.7rem; font-weight: 600; color: #92400e; }
        .rubric-field select, .rubric-field input, .rubric-field textarea {
            padding: 0.4rem;
            border: 1px solid #fcd34d;
            border-radius: 4px;
            font-size: 0.85rem;
            background: white;
        }
        .checks-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .check-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            background: white;
            border: 1px solid #fcd34d;
            border-radius: 12px;
            font-size: 0.75rem;
        }
        .check-tag button {
            background: none;
            border: none;
            color: #991b1b;
            cursor: pointer;
            padding: 0;
            font-size: 0.8rem;
        }

        /* METADATA EDITOR */
        .metadata-section {
            background: #f0fdf4;
            padding: 1rem;
            border-radius: 6px;
            border: 1px dashed #86efac;
        }
        .metadata-section .section-label { color: #166534; }
        .metadata-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.75rem;
        }
        .metadata-field { display: flex; flex-direction: column; gap: 0.25rem; }
        .metadata-field label { font-size: 0.7rem; font-weight: 600; color: #166534; }
        .metadata-field input, .metadata-field select {
            padding: 0.4rem;
            border: 1px solid #86efac;
            border-radius: 4px;
            font-size: 0.85rem;
            background: white;
        }

        /* GRADING EDITOR */
        .grading-section {
            background: #ecfdf5;
            padding: 1rem;
            border-radius: 6px;
            border: 1px dashed #6ee7b7;
        }
        .grading-section .section-label { color: #047857; }
        .grading-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        .grading-field { display: flex; flex-direction: column; gap: 0.25rem; }
        .grading-field label { font-size: 0.7rem; font-weight: 600; color: #047857; }
        .grading-field select, .grading-field input, .grading-field textarea {
            padding: 0.4rem;
            border: 1px solid #6ee7b7;
            border-radius: 4px;
            font-size: 0.85rem;
            background: white;
        }

        /* WORD BANK EDITOR */
        .word-bank-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }
        .word-bank-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: white;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            border: 1px solid #fcd34d;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .word-bank-item input { 
            flex: 1; 
            padding: 0.3rem 0.5rem; 
            border: 1px solid #e5e7eb; 
            border-radius: 4px; 
            font-size: 0.85rem; 
            min-width: 80px;
            max-width: 150px;
        }
        .word-bank-item input:focus {
            outline: none;
            border-color: #f59e0b;
            box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
        }
        .word-bank-item .delete-btn {
            background: none;
            border: none;
            color: #dc2626;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.8rem;
            border-radius: 4px;
        }
        .word-bank-item .delete-btn:hover {
            background: #fee2e2;
        }

        /* GROUPS EDITOR (for sorting/classification) */
        .groups-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }
        .groups-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            background: #fef3c7;
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid #fcd34d;
        }
        .groups-item .group-id { width: 40px; padding: 0.4rem; border: 1px solid #fcd34d; border-radius: 4px; font-size: 0.85rem; font-weight: 600; text-align: center; background: white; }
        .groups-item input.group-text { flex: 1; padding: 0.4rem; border: 1px solid #fcd34d; border-radius: 4px; font-size: 0.85rem; }

        /* PAIRS EDITOR (for MATCH type - v4.0) */
        .pair-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            border: 1px solid #c4b5fd;
        }
        .pair-item .pair-num {
            font-size: 0.75rem;
            font-weight: 700;
            color: #6d28d9;
            min-width: 24px;
        }
        .pair-item input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            font-size: 0.85rem;
            min-width: 100px;
        }
        .pair-item input:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
        }
        .pair-item .pair-arrow {
            color: #8b5cf6;
            font-weight: bold;
            font-size: 1rem;
        }
        .pair-item .delete-btn {
            background: none;
            border: none;
            color: #dc2626;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.8rem;
            border-radius: 4px;
        }
        .pair-item .delete-btn:hover {
            background: #fee2e2;
        }
        
        /* TABLE EDITOR STYLES (v4.6) */
        .table-editor-section {
            background: white;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        .table-style-options {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            align-items: center;
            padding: 0.75rem 1rem;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        .table-style-options label {
            font-size: 0.8rem;
            color: #374151;
            cursor: pointer;
        }
        .table-grid-select {
            padding: 0.35rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.8rem;
            background: white;
        }
        .table-grid-editor-container {
            overflow-x: auto;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: #fafafa;
        }
        .table-grid-editor {
            border-collapse: collapse;
            width: 100%;
            min-width: 400px;
        }
        .table-grid-editor th,
        .table-grid-editor td {
            border: 1px solid #d1d5db;
            padding: 0;
            position: relative;
        }
        .table-grid-editor th {
            background: #f1f5f9;
            font-weight: 600;
            font-size: 0.8rem;
            color: #475569;
        }
        .table-grid-editor .header-cell {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .table-grid-editor .header-input {
            flex: 1;
            border: none;
            padding: 0.5rem;
            font-size: 0.8rem;
            font-weight: 600;
            background: transparent;
            text-align: center;
            min-width: 80px;
        }
        .table-grid-editor .cell-input {
            width: 100%;
            border: none;
            padding: 0.5rem;
            font-size: 0.85rem;
            background: white;
            min-width: 80px;
        }
        .table-grid-editor .cell-input:focus,
        .table-grid-editor .header-input:focus {
            outline: 2px solid var(--primary);
            outline-offset: -2px;
        }
        .table-grid-editor .corner-cell {
            background: #e2e8f0;
            min-width: 40px;
        }
        .table-grid-editor .row-actions,
        .table-grid-editor .col-actions {
            padding: 0.25rem;
            text-align: center;
            background: #fef2f2;
        }
        .table-grid-editor .btn-delete-row,
        .table-grid-editor .btn-delete-col {
            background: #fee2e2;
            color: #dc2626;
            border: 1px solid #fecaca;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.65rem;
        }
        .table-grid-editor .btn-delete-row:hover,
        .table-grid-editor .btn-delete-col:hover {
            background: #fecaca;
        }
        
        /* Column resize handles (v4.9) */
        .table-grid-editor .col-resize-handle {
            position: absolute;
            right: -3px;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: col-resize;
            background: transparent;
            z-index: 10;
        }
        .table-grid-editor .col-resize-handle:hover,
        .table-grid-editor .col-resize-handle.resizing {
            background: #3b82f6;
        }
        .table-grid-editor th.resizable {
            position: relative;
        }
        .table-grid-editor .col-width-indicator {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.75);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
        }
        .table-grid-editor th.resizing .col-width-indicator {
            opacity: 1;
        }
        
        .pairs-column {
            margin-bottom: 0.75rem;
        }
        .pairs-column-header {
            font-size: 0.7rem;
            font-weight: 700;
            color: #7c3aed;
            text-transform: uppercase;
            margin-bottom: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .pairs-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            background: #f5f3ff;
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid #c4b5fd;
        }
        .pairs-item .pair-id { width: 40px; padding: 0.4rem; border: 1px solid #c4b5fd; border-radius: 4px; font-size: 0.85rem; font-weight: 600; text-align: center; background: white; }
        .pairs-item input.pair-text { flex: 1; padding: 0.4rem; border: 1px solid #c4b5fd; border-radius: 4px; font-size: 0.85rem; }

        /* SECTION LAYOUT TOGGLE */
        .section-layout-toggle {
            display: flex;
            background: #e5e7eb;
            border-radius: 4px;
            padding: 2px;
        }
        .section-layout-btn {
            padding: 2px 8px;
            font-size: 0.65rem;
            font-weight: 600;
            border-radius: 3px;
            cursor: pointer;
            border: none;
            background: transparent;
            color: var(--text-muted);
        }
        .section-layout-btn.active {
            background: white;
            color: var(--text-main);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        /* GRID LAYOUT FOR SECTIONS (text left, media right) */
        .section-content-grid {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 1rem;
            align-items: start;
        }
        .section-content-grid .section-text-area {
            flex: 1;
            min-width: 0;
        }
        .section-content-grid .section-media-area {
            width: 200px;
            flex-shrink: 0;
        }
        .section-content-grid .section-media-area .asset-item {
            flex-direction: column;
        }
        .section-content-grid .section-media-area .asset-preview {
            width: 100%;
            height: 120px;
        }

        /* STACK LAYOUT FOR SECTIONS (default - text above media) */
        .section-content-stack {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .section-content-stack .section-text-area {
            width: 100%;
        }
        .section-content-stack .section-media-area {
            width: 100%;
        }

        /* SUB-QUESTION ENHANCEMENTS */
        .sub-question-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .sub-question-type-select {
            padding: 2px 6px;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            border-radius: 4px;
        }
        .delete-sub-btn {
            padding: 2px 6px;
            font-size: 0.7rem;
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fecaca;
            border-radius: 4px;
            cursor: pointer;
        }
        .delete-sub-btn:hover { background: #fecaca; }

        /* SAVE BUTTON STATES */
        .btn-save {
            background: var(--success);
            color: white;
            border-color: var(--success);
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-save:hover:not(:disabled) { 
            background: #15803d; 
            border-color: #15803d;
        }
        .btn-save:disabled {
            background: #d1d5db;
            border-color: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .btn-save.has-changes {
            animation: pulse-save 2s infinite;
        }
        @keyframes pulse-save {
            0%, 100% { box-shadow: 0 0 0 0 rgba(22, 163, 74, 0.4); }
            50% { box-shadow: 0 0 0 6px rgba(22, 163, 74, 0); }
        }
        .unsaved-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--warning);
            border-radius: 50%;
            margin-right: 6px;
            animation: blink 1.5s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
    </style>
</head>
<body>

    <!-- BRYT SIDEBAR -->
    <nav class="bryt-sidebar">
        <div class="bryt-sidebar-header">
            <div class="bryt-logo">Bryt</div>
        </div>

        <div class="bryt-nav-section">
            <div class="bryt-nav-section-title">School</div>
            <a href="index.html" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ“Š</span>
                <span>Dashboard</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ«</span>
                <span>School Details</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ“…</span>
                <span>School Schedule</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ‘©â€ðŸ«</span>
                <span>Teachers</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ‘¨â€ðŸŽ“</span>
                <span>Students</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ‘¥</span>
                <span>Manage Users</span>
            </a>
            <a href="curriculum.html" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ“š</span>
                <span>Curriculum</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ“·</span>
                <span>Classroom Photos</span>
            </a>
        </div>

        <div class="bryt-nav-section">
            <div class="bryt-nav-section-title">Admin Tools</div>
            <a href="index.html" class="bryt-nav-item active">
                <span class="bryt-nav-icon">ðŸ“–</span>
                <span>Curriculum/Training</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ“</span>
                <span>Surveys</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ“ˆ</span>
                <span>Analytics</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ“‹</span>
                <span>AC Dashboard</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ¢</span>
                <span>Manage Schools</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">ðŸ”</span>
                <span>Bryt User Accounts</span>
            </a>
            <a href="#" class="bryt-nav-item">
                <span class="bryt-nav-icon">âš ï¸</span>
                <span>Inactive Users</span>
            </a>
        </div>
    </nav>

    <!-- MAIN WRAPPER -->
    <div class="main-wrapper">
        <!-- BRYT HEADER -->
        <header class="bryt-header">
            <h1 class="bryt-page-title">Assessment Question Management</h1>
            <div class="bryt-header-right">
                <div class="bryt-user-avatar">A</div>
            </div>
        </header>

        <!-- TOOL CONTENT -->
        <div class="tool-content">
            <!-- HORIZONTAL TAB NAVIGATION -->
            <nav class="tab-navigation">
                <div class="nav-tab active" id="nav-import" onclick="switchWorkflow('import')">Create/ Import Questions</div>
                <div class="nav-tab" id="nav-library" onclick="switchWorkflow('library')">Question Library</div>
            </nav>

            <!-- APP CONTENT -->
            <div class="app-content">

                <!-- Content Header -->
                <header class="content-header">
                    <div class="header-brand">
                        <div class="header-title">Question Editor</div>
                        <div class="header-meta" id="header-meta">
                            <span class="badge-mode badge-import" id="mode-badge">CREATE/ IMPORT MODE</span>
                        </div>
                    </div>
                    
                    <!-- Actions: Dynamic based on Workflow -->
                    <div class="actions" id="action-bar">
                        <input type="file" id="file-input" accept=".jsonl,.json">
                        <input type="file" id="image-files-input" accept="image/*" multiple style="display:none;">
                        
                        <!-- Step 1: Upload Questions (active initially) -->
                        <div class="workflow-step active" id="step-upload">
                            <span class="step-badge"><span>1</span></span>
                        <button class="btn" id="btn-upload" onclick="document.getElementById('file-input').click()">ðŸ“ Upload JSON/JSONL</button>
                        </div>
                        
                        <span class="workflow-connector" id="connector-1">â†’</span>
                        
                        <!-- Step 2: Upload Images (pending initially) -->
                        <div class="workflow-step pending" id="step-images">
                            <span class="step-badge"><span>2</span></span>
                            <button class="btn" id="btn-upload-images" disabled onclick="document.getElementById('image-files-input').click()">ðŸ–¼ï¸ Upload Image(s)</button>
                            <button class="btn-skip" id="btn-skip-images" disabled onclick="skipImageUpload()">Skip â†’</button>
                        </div>
                        
                        <span class="workflow-connector" id="connector-2">â†’</span>
                        
                        <!-- Step 3: Publish (pending initially) -->
                        <div class="workflow-step pending" id="step-publish">
                            <span class="step-badge" id="step-publish-badge"><span>3</span></span>
                            <button class="btn btn-primary" id="btn-action" disabled onclick="downloadJSONL()">Publish All</button>
                        </div>
                    </div>
                </header>

                <!-- Main Layout -->
                <div class="workspace">
                    <aside class="panel">
                        <!-- Module 1: IMPORT (File Based) -->
                        <div id="module-import" class="panel-module active">
                            <div class="panel-filter">
                                <div style="font-size:0.75rem; color:#666; margin-bottom:0.25rem;">Upload questions to review and publish.</div>
                            </div>
                            <div class="panel-header-status">
                                 <span id="import-count">0 Items</span>
                                 <span id="import-status">No File</span>
                            </div>
                            <div id="import-list" class="q-list"></div>
                        </div>

                        <!-- Module 2: LIBRARY (DB Based) -->
                        <div id="module-library" class="panel-module">
                            <div class="panel-search">
                                <div class="search-row">
                                    <select class="search-select" id="filter-grade">
                                        <option value="grade_3">Grade 3</option>
                                        <option value="grade_4">Grade 4</option>
                                    </select>
                                    <select class="search-select" id="filter-subject">
                                        <option value="mathematics">Mathematics</option>
                                        <option value="english">English</option>
                                    </select>
                                </div>
                                <div class="search-row">
                                     <select class="search-select" id="filter-chapter">
                                        <option value="all">All Chapters</option>
                                        <option value="ch_measurement">Measurement</option>
                                        <option value="ch_addition">Addition</option>
                                        <option value="ch_subtraction">Subtraction</option>
                                        <option value="ch1">Ch 1 (Eng)</option>
                                    </select>
                                </div>
                                <button class="fetch-btn" onclick="fetchQuestions()">Fetch Questions</button>
                            </div>
                            <div class="panel-header-status">
                                <span id="library-count">0 Items</span>
                                <span id="library-status">Ready</span>
                            </div>
                            <div id="library-list" class="q-list"></div>
                        </div>
                    </aside>

                    <main class="editor" id="main-editor">
                        <div id="empty-state" class="empty-state">
                            <p>Select a question to start editing.</p>
                        </div>

                <div id="editor-wrapper" style="display:none;">
                    <div class="editor-card">
                        <!-- Metadata Header -->
                        <div class="card-header">
                            <div class="header-top">
                                <div class="meta-group">
                                    <span class="badge-draft" id="meta-id" style="background:#eff6ff; color:var(--primary); padding:4px 8px; border-radius:4px; font-weight:700; font-size:0.8rem;">ID</span>
                                    <select class="btn btn-sm" id="meta-type" onchange="updateMeta('type', this.value)" title="Question Type">
                                        <option value="MCQ">MCQ</option>
                                        <option value="FIB">Fill in Blank</option>
                                        <option value="MATCH">Match</option>
                                        <option value="SUBJECTIVE">Subjective</option>
                                        <option value="TABLE">Table</option>
                                        <option value="COMPOSITE">Composite</option>
                                    </select>
                                    <select class="btn btn-sm" id="meta-pool-type" onchange="updateMeta('pool_type', this.value)">
                                        <option value="practice">Practice Pool</option>
                                        <option value="exam">Exam Pool</option>
                                    </select>
                                    <select class="btn btn-sm" id="meta-difficulty" onchange="updateMeta('difficulty', this.value)">
                                        <option value="easy">Easy</option>
                                        <option value="medium">Medium</option>
                                        <option value="hard">Hard</option>
                                    </select>
                                    <div style="display:flex; align-items:center; gap:4px;">
                                        <input type="number" class="btn btn-sm" style="width:60px; text-align:right;" id="meta-points" onchange="updateMeta('points', this.value)" title="Points">
                                        <span style="font-size:0.8rem; color:var(--text-muted);">marks</span>
                                    </div>
                                </div>
                                <button class="btn btn-sm btn-danger" onclick="deleteQuestion()" style="background:#fee2e2; color:#991b1b; border-color:#fecaca;">Delete</button>
                            </div>
                            <!-- Second row for location metadata -->
                            <div class="header-top" style="padding-top:0; border-top:1px solid var(--border); margin-top:0;">
                                <div class="meta-group" style="flex-wrap:wrap;">
                                    <div style="display:flex; align-items:center; gap:4px;">
                                        <label style="font-size:0.65rem; color:var(--text-muted); font-weight:600;">Grade:</label>
                                        <input type="text" class="btn btn-sm" style="width:80px;" id="meta-grade" onchange="updateMeta('grade_id', this.value)" placeholder="grade_3">
                                    </div>
                                    <div style="display:flex; align-items:center; gap:4px;">
                                        <label style="font-size:0.65rem; color:var(--text-muted); font-weight:600;">Subject:</label>
                                        <input type="text" class="btn btn-sm" style="width:100px;" id="meta-subject" onchange="updateMeta('subject_id', this.value)" placeholder="mathematics">
                                    </div>
                                    <div style="display:flex; align-items:center; gap:4px;">
                                        <label style="font-size:0.65rem; color:var(--text-muted); font-weight:600;">Unit:</label>
                                        <input type="text" class="btn btn-sm" style="width:80px;" id="meta-unit" onchange="updateMeta('unit_id', this.value)" placeholder="ch1">
                                    </div>
                                    <div style="display:flex; align-items:center; gap:4px;">
                                        <label style="font-size:0.65rem; color:var(--text-muted); font-weight:600;">Section:</label>
                                        <select class="btn btn-sm" style="width:60px;" id="meta-section" onchange="updateMeta('section_id', this.value)">
                                            <option value="A">A</option>
                                            <option value="B">B</option>
                                            <option value="C">C</option>
                                            <option value="D">D</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            <!-- TABS -->
                            <div class="card-tabs">
                                <div class="tab-btn active" id="tab-preview" onclick="switchTab('preview')">Preview</div>
                                <div class="tab-btn" id="tab-edit" onclick="switchTab('edit')">Edit</div>
                            </div>
                        </div>

                        <!-- Content Body -->
                        <div class="card-body">
                            
                            <!-- VIEW: EDIT (Container for Graph/JSON) -->
                            <div id="view-edit" class="edit-view-container active">
                                <!-- Toolbar -->
                                <div class="editor-toolbar">
                                    <div class="toolbar-left">
                                        <span style="font-size:0.75rem; color:var(--text-muted);">Use layout toggles in each section below</span>
                                        <span id="unsaved-status" style="display:none; font-size:0.75rem; color:var(--warning); margin-left:1rem;">
                                            <span class="unsaved-indicator"></span>Unsaved changes
                                        </span>
                                    </div>
                                    
                                    <div class="toolbar-right">
                                        <!-- SUB VIEW TOGGLE -->
                                        <div class="view-toggle">
                                            <button class="view-toggle-btn active" id="subview-graphical" onclick="switchSubView('graphical')">Graphical</button>
                                            <button class="view-toggle-btn" id="subview-json" onclick="switchSubView('json')">Content JSON</button>
                                        </div>
                                    </div>
                                </div>

                                <!-- SUB-VIEW: GRAPHICAL (Default) -->
                                <div id="sub-view-graphical" class="graphical-view">

                                    <!-- Main Prompt -->
                                    <div class="content-section" style="background:white; padding:1rem; border-radius:6px; border:1px solid var(--border);">
                                        <div class="section-header">
                                            <label class="section-label">QUESTION CONTENT</label>
                                        </div>
                                        <div id="prompt-content" class="section-content-stack">
                                            <div class="section-text-area">
                                                <textarea class="input-bare prompt-input" id="input-prompt" oninput="updatePrompt(this.value)" placeholder="Enter text..."></textarea>
                                            </div>
                                            <div class="section-media-area">
                                                <div id="prompt-assets" class="asset-container">
                                                    <span style="font-size:0.7rem; color:#999;">Images: [[image:tag]] | Blanks: [[gap]] | Math: $x^2$ or $$x^2$$ | **bold** *italic*</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Stimulus Section -->
                                    <div id="stimulus-section" class="content-section" style="display:none; background:white; padding:1rem; border-radius:6px; border:1px solid var(--border);">
                                        <div class="section-header">
                                            <label class="section-label">SHARED CONTEXT (STIMULUS)</label>
                                            <div style="display:flex; gap:0.5rem; align-items:center;">
                                                <button class="btn btn-sm" onclick="insertImageTag('input-stimulus')">+ Add Image</button>
                                                <button class="btn btn-sm" onclick="toggleWordBank()" id="toggle-wordbank-btn">+ Word Bank</button>
                                                <button class="btn btn-sm" onclick="toggleGroups()" id="toggle-groups-btn" style="background:#fef3c7; border-color:#fcd34d;">+ Groups</button>
                                                <button class="btn btn-sm" onclick="togglePairs()" id="toggle-pairs-btn" style="background:#f5f3ff; border-color:#c4b5fd;">+ Pairs</button>
                                                <button class="remove-section-btn" onclick="removeSection('stimulus')">âœ• Remove</button>
                                            </div>
                                        </div>
                                        <div id="stimulus-content" class="section-content-stack">
                                            <div class="section-text-area">
                                                <textarea class="input-bare" id="input-stimulus" oninput="updateStimulus(this.value)" placeholder="Enter text..."></textarea>
                                            </div>
                                            <div class="section-media-area">
                                        <div id="stimulus-assets" class="asset-container"></div>
                                            </div>
                                    </div>

                                        <!-- Groups Section (inside Stimulus - for sorting/classification) -->
                                        <div id="groups-section" class="groups-section" style="display:none;">
                                            <div class="section-header">
                                                <label style="font-size:0.7rem; font-weight:700; color:#b45309;">GROUPS (Categories for Sorting)</label>
                                                <button class="btn btn-sm" onclick="addGroupItem()" style="font-size:0.7rem; background:#fef3c7; border-color:#fcd34d;">+ Add Group</button>
                                            </div>
                                            <div id="groups-list"></div>
                                        </div>

                                    </div>

                                    <!-- Options Section (for MCQ/sequencing/sorting types) -->
                                    <div id="options-section" class="content-section options-section" style="display:none;">
                                        <div class="section-header">
                                            <label class="section-label" id="options-section-label">OPTIONS</label>
                                            <div style="display:flex; gap:0.5rem; align-items:center;">
                                                <div class="section-layout-toggle" id="options-layout-toggle">
                                                    <button class="section-layout-btn" onclick="setOptionsLayoutMain('vertical')" data-layout="vertical" id="btn-options-layout-vertical">â˜° Vertical</button>
                                                    <button class="section-layout-btn active" onclick="setOptionsLayoutMain('horizontal')" data-layout="horizontal" id="btn-options-layout-horizontal">âŠž Horizontal</button>
                                                </div>
                                                <button class="btn btn-sm" onclick="addOption()">+ Add Option</button>
                                                <button class="remove-section-btn" onclick="removeSection('options')">âœ• Remove</button>
                                            </div>
                                        </div>
                                        <div id="options-list"></div>
                                    </div>

                                    <!-- Word Bank Section (options_pool for FIB / shared for COMPOSITE) -->
                                    <div id="word-bank-section" class="content-section" style="display:none; background:#fffbeb; padding:1rem; border-radius:6px; border:1px solid #fcd34d;">
                                        <div class="section-header">
                                            <label class="section-label" id="word-bank-label" style="color:#92400e;">WORD BANK (options_pool)</label>
                                            <div style="display:flex; gap:0.5rem; align-items:center;">
                                                <button class="btn btn-sm" onclick="addWordBankItem()" style="font-size:0.7rem; background:#fef3c7; border-color:#fcd34d; color:#92400e;">+ Add Word</button>
                                            </div>
                                        </div>
                                        <p id="word-bank-hint" style="font-size:0.7rem; color:#b45309; margin:0.5rem 0;">Words available for fill-in-the-blank questions</p>
                                        <div id="word-bank-list" style="display:flex; flex-wrap:wrap; gap:0.5rem;"></div>
                                    </div>

                                    <!-- Pairs Section (for MATCH type - v4.0) -->
                                    <div id="pairs-section" class="content-section" style="display:none; background:#f5f3ff; padding:1rem; border-radius:6px; border:1px solid #c4b5fd;">
                                        <div class="section-header">
                                            <label class="section-label" style="color:#6d28d9;">MATCH PAIRS</label>
                                            <div style="display:flex; gap:0.5rem; align-items:center;">
                                                <button class="btn btn-sm" onclick="addMatchPair()" style="font-size:0.7rem; background:#ede9fe; border-color:#c4b5fd; color:#6d28d9;">+ Add Pair</button>
                                            </div>
                                        </div>
                                        <p style="font-size:0.7rem; color:#7c3aed; margin:0.5rem 0;">Match items from Column A with Column B</p>
                                        <div id="pairs-list" style="display:flex; flex-direction:column; gap:0.5rem;"></div>
                                    </div>

                                    <!-- TABLE Editor Section (for TABLE type - v4.6) -->
                                    <div id="table-editor-section" class="content-section table-editor-section" style="display:none;">
                                        <div class="section-header" style="margin-bottom:1rem;">
                                            <label class="section-label">ðŸ“Š TABLE EDITOR</label>
                                            <div style="display:flex; gap:0.5rem; align-items:center;">
                                                <button class="btn btn-sm" onclick="addTableRow()">+ Row</button>
                                                <button class="btn btn-sm" onclick="addTableColumn()">+ Column</button>
                                            </div>
                                        </div>
                                        
                                        <!-- Table Style Options -->
                                        <div class="table-style-options" style="margin-bottom:1rem; display:flex; flex-wrap:wrap; gap:1rem; align-items:center;">
                                            <label style="display:flex; align-items:center; gap:0.5rem;">
                                                <span style="font-weight:600; font-size:0.8rem;">Grid Lines:</span>
                                                <select id="table-grid-lines" class="table-grid-select" onchange="updateTableGridLines(this.value)">
                                                    <option value="all">All</option>
                                                    <option value="none">None</option>
                                                    <option value="horizontal">Horizontal</option>
                                                    <option value="vertical">Vertical</option>
                                                </select>
                                            </label>
                                            <label style="display:flex; align-items:center; gap:0.5rem;">
                                                <input type="checkbox" id="table-hide-header" onchange="updateTableHideHeader(this.checked)">
                                                <span style="font-weight:600; font-size:0.8rem;">Hide Header Row</span>
                                            </label>
                                            <button class="btn btn-sm" style="font-size:0.7rem; padding:0.25rem 0.5rem;" onclick="clearColumnWidths()" title="Reset all column widths to auto">â†º Reset Widths</button>
                                        </div>
                                        <div style="font-size:0.7rem; color:#6b7280; margin-bottom:0.5rem;">ðŸ’¡ Drag column borders to resize. Widths are saved automatically.</div>
                                        
                                        <!-- Editable Table Grid -->
                                        <div id="table-grid-editor" class="table-grid-editor-container"></div>
                                    </div>

                                    <!-- Sub-Questions Section -->
                                    <div id="subquestions-section" class="content-section" style="display:none; background:white; padding:1rem; border-radius:6px; border:1px solid var(--border);">
                                        <div class="section-header">
                                            <label class="section-label">SUB-QUESTIONS</label>
                                            <div style="display:flex; gap:0.5rem; align-items:center;">
                                                <div class="section-layout-toggle" id="subquestions-layout-toggle">
                                                    <button class="section-layout-btn" onclick="setLayout('vertical')" data-layout="vertical" id="btn-layout-vertical">â˜° Vertical</button>
                                                    <button class="section-layout-btn active" onclick="setLayout('horizontal')" data-layout="horizontal" id="btn-layout-horizontal">âŠž Horizontal</button>
                                                </div>
                                                <button class="btn btn-sm" onclick="addSubQuestion()">+ Add Sub-Question</button>
                                                <button class="remove-section-btn" onclick="removeSection('subquestions')">âœ• Remove</button>
                                            </div>
                                        </div>
                                        <div id="sub-questions-list" class="sub-questions-wrapper"></div>
                                    </div>

                                    <!-- Solution Section -->
                                    <div id="solution-section" class="content-section solution-section" style="background:#f0fdf4; border:1px solid #86efac;">
                                        <div class="section-header">
                                            <label class="section-label" style="color:#166534;">âœ“ SOLUTION / ANSWER KEY</label>
                                        </div>
                                        <div style="padding:0.5rem;">
                                            <textarea class="input-bare" id="input-solution" oninput="updateSolution(this.value)" placeholder="Enter the correct answer and explanation..." style="color:#166534; min-height:80px; background:white;"></textarea>
                                        </div>
                                    </div>

                                </div>

                                <!-- SUB-VIEW: Content JSON (Read Only) -->
                                <div id="sub-view-json" class="json-view">
                                    <textarea id="json-ro-textarea" class="json-editor" readonly spellcheck="false"></textarea>
                                    <div class="json-footer">
                                        <span style="color:#aaa;">â— Read-only (Updates automatically)</span>
                                    </div>
                                </div>

                            </div>

                            <!-- VIEW: PREVIEW -->
                            <div id="view-preview" class="preview-view-container">
                                <div class="a4-pages-container" id="a4-pages-container">
                                <div class="a4-page" id="a4-content">
                                    <!-- Rendered Content Goes Here -->
                                    </div>
                                </div>
                            </div>

                            </div>
                        </div>
                    </div>
                    </main>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden Input for Image Upload -->
    <input type="file" id="image-upload-input" accept="image/*">

    <!-- SHARED PARSING MODULE -->
    <script src="question-parser.js"></script>
    <!-- LAYOUT GENERATION MODULE -->
    <script src="layout-parser.js"></script>

    <!-- SCRIPT -->
    <script>
        // --- GLOBAL STATE ---
        // 1. Data Store for Import Workflow
        let importData = [];
        // 2. Data Store for Library Workflow (Mock DB)
        let libraryData = []; // Populated via fetch
        // 3. Pointer to currently active dataset (reference)
        let activeData = null; // Points to importData or libraryData
        // 4. Uploaded Images Store (maps tag names to data URLs)
        let uploadedImages = {};
        
        let activeIndex = null;
        let activeWorkflow = 'import'; // 'import' or 'library'
        let activeUploadCallback = null;
        let workflowState = { step1: false, step2: false, step3: false }; // Track workflow completion

        // --- WORKFLOW ANIMATION MANAGEMENT ---
        function updateWorkflowState(completedStep) {
            const step1 = document.getElementById('step-upload');
            const step2 = document.getElementById('step-images');
            const step3 = document.getElementById('step-publish');
            const btn1 = document.getElementById('btn-upload');
            const btn2 = document.getElementById('btn-upload-images');
            const btn3 = document.getElementById('btn-action');
            const btnSkip = document.getElementById('btn-skip-images');
            const conn1 = document.getElementById('connector-1');
            const conn2 = document.getElementById('connector-2');

            if (completedStep === 1) {
                workflowState.step1 = true;
                // Step 1 completed - disable it
                step1.classList.remove('active');
                step1.classList.add('completed', 'just-completed');
                btn1.disabled = true;
                setTimeout(() => step1.classList.remove('just-completed'), 400);
                
                // Step 2 becomes active - enable it and skip button
                step2.classList.remove('pending');
                step2.classList.add('active');
                btn2.disabled = false;
                btnSkip.disabled = false;
                conn1.classList.add('completed');
            }
            
            if (completedStep === 2) {
                workflowState.step2 = true;
                // Step 2 completed - disable it
                step2.classList.remove('active');
                step2.classList.add('completed', 'just-completed');
                btn2.disabled = true;
                btnSkip.disabled = true;
                setTimeout(() => step2.classList.remove('just-completed'), 400);
                
                // Step 3 becomes active - enable it
                step3.classList.remove('pending');
                step3.classList.add('active');
                btn3.disabled = false;
                conn2.classList.add('completed');
            }
            
            if (completedStep === 3) {
                workflowState.step3 = true;
                // All steps completed
                step3.classList.remove('active');
                step3.classList.add('completed', 'just-completed');
                btn3.disabled = true;
                setTimeout(() => step3.classList.remove('just-completed'), 400);
            }
        }

        function resetWorkflowState() {
            workflowState = { step1: false, step2: false, step3: false };
            const step1 = document.getElementById('step-upload');
            const step2 = document.getElementById('step-images');
            const step3 = document.getElementById('step-publish');
            const btn1 = document.getElementById('btn-upload');
            const btn2 = document.getElementById('btn-upload-images');
            const btn3 = document.getElementById('btn-action');
            const btnSkip = document.getElementById('btn-skip-images');
            const conn1 = document.getElementById('connector-1');
            const conn2 = document.getElementById('connector-2');

            [step1, step2, step3].forEach(el => {
                el.classList.remove('completed', 'active', 'pending', 'just-completed');
            });
            [conn1, conn2].forEach(el => {
                el.classList.remove('completed', 'active');
            });

            // Step 1 active, others pending
            step1.classList.add('active');
            btn1.disabled = false;
            
            step2.classList.add('pending');
            btn2.disabled = true;
            btnSkip.disabled = true;
            
            step3.classList.add('pending');
            btn3.disabled = true;
        }

        // Skip the image upload step
        function skipImageUpload() {
            // Mark step 2 as completed (skipped)
            updateWorkflowState(2);
        }

        // MOCK DATABASE (using new schema format v2)
        const mockDatabase = [
            { 
                question_id: "db_q1", 
                taxonomy: { grade_id: "grade_3", subject_id: "mathematics", unit_id: "ch_measurement", section_id: "A", type: "composite", difficulty: "easy", pool: "practice", skill_tags: [] },
                content: { 
                    prompt: { text: "Fill in the blanks. Choose words from brackets.", assets: [] }, 
                    subquestions: [{ sub_id: "a", type: "fill_blank", prompt: { text: "Standard unit for length is ____ (m/kg)", assets: [] }, grading: { kind: "text", values: ["m"], points: "1" } }] 
                },
                grading: { kind: "text", values: [], points: "2" },
                metadata: { ui_hint: "cloze_text", version: 2, source: "Manual" }
            },
            { 
                question_id: "db_q2", 
                taxonomy: { grade_id: "grade_3", subject_id: "mathematics", unit_id: "ch_addition", section_id: "B", type: "short_answer", difficulty: "medium", pool: "exam", skill_tags: ["addition"] },
                content: { prompt: { text: "Solve 345 + 123", assets: [] } },
                grading: { kind: "sample_text", values: ["468"], points: "3" },
                metadata: { ui_hint: "rich_text_editor", version: 2, source: "Manual" }
            },
            { 
                question_id: "db_q3", 
                taxonomy: { grade_id: "grade_3", subject_id: "english", unit_id: "ch1", section_id: "A", type: "mcq", difficulty: "easy", pool: "practice", skill_tags: ["grammar"] },
                content: { 
                    prompt: { text: "Tick the noun.", assets: [] }, 
                    options: [{ opt_id: "a", text: "Run", assets: [] }, { opt_id: "b", text: "Cat", assets: [] }, { opt_id: "c", text: "Blue", assets: [] }] 
                },
                grading: { kind: "single_selection", values: ["b"], points: "1" },
                metadata: { ui_hint: "selection_list", version: 2, source: "Manual" }
            },
            { 
                question_id: "db_q4", 
                taxonomy: { grade_id: "grade_3", subject_id: "english", unit_id: "ch1", section_id: "B", type: "match_columns", difficulty: "medium", pool: "practice", skill_tags: ["vocabulary"] },
                content: { 
                    prompt: { text: "Match the words with their meanings.", assets: [] },
                    stimulus: {
                        pairs: {
                            left_column: [{ id: "l1", text: "Bright" }, { id: "l2", text: "Happy" }],
                            right_column: [{ id: "r1", text: "Full of light" }, { id: "r2", text: "Feeling joy" }]
                        }
                    }
                },
                grading: { kind: "matching", values: [{ pair: ["l1", "r1"] }, { pair: ["l2", "r2"] }], points: "2" },
                metadata: { ui_hint: "match_connector", version: 2, source: "Manual" }
            },
            { 
                question_id: "db_q5", 
                taxonomy: { grade_id: "grade_3", subject_id: "mathematics", unit_id: "ch1", section_id: "A", type: "sequencing", difficulty: "easy", pool: "practice", skill_tags: ["ordering"] },
                content: { 
                    prompt: { text: "Arrange the numbers in ascending order.", assets: [] },
                    options: [{ opt_id: "n1", text: "45" }, { opt_id: "n2", text: "12" }, { opt_id: "n3", text: "78" }, { opt_id: "n4", text: "23" }]
                },
                grading: { kind: "sequencing", values: [{ order: ["n2", "n4", "n1", "n3"] }], points: "2" },
                metadata: { ui_hint: "reorder_list", version: 2, source: "Manual" }
            },
            { 
                question_id: "db_q6", 
                taxonomy: { grade_id: "grade_3", subject_id: "evs", unit_id: "ch1", section_id: "A", type: "sorting", difficulty: "medium", pool: "practice", skill_tags: ["classification"] },
                content: { 
                    prompt: { text: "Sort the items into the correct categories.", assets: [] },
                    stimulus: {
                        groups: [{ group_id: "a", text: "Living Things" }, { group_id: "b", text: "Non-Living Things" }]
                    },
                    options: [{ opt_id: "i1", text: "Dog" }, { opt_id: "i2", text: "Rock" }, { opt_id: "i3", text: "Tree" }, { opt_id: "i4", text: "Chair" }]
                },
                grading: { kind: "grouping", values: [{ group: "a", items: ["i1", "i3"] }, { group: "b", items: ["i2", "i4"] }], points: "4" },
                metadata: { ui_hint: "sort_and_categorize", version: 2, source: "Manual" }
            }
        ];

        // --- WORKFLOW SWITCHING ---
        function switchWorkflow(mode) {
            activeWorkflow = mode;
            
            // 1. Update Tab Navigation UI
            document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
            document.getElementById(`nav-${mode}`).classList.add('active');

            // 2. Update Panel Modules
            document.querySelectorAll('.panel-module').forEach(el => el.classList.remove('active'));
            document.getElementById(`module-${mode}`).classList.add('active');

            // 3. Update Header Meta
            const badge = document.getElementById('mode-badge');
            const actionBtn = document.getElementById('btn-action');
            const uploadBtn = document.getElementById('btn-upload');
            const uploadImagesBtn = document.getElementById('btn-upload-images');

            // Get workflow step containers
            const stepUpload = document.getElementById('step-upload');
            const stepImages = document.getElementById('step-images');
            const stepPublish = document.getElementById('step-publish');
            const connector1 = document.getElementById('connector-1');
            const connector2 = document.getElementById('connector-2');

            if (mode === 'import') {
                badge.innerText = "CREATE/ IMPORT MODE";
                badge.className = "badge-mode badge-import";
                activeData = importData;
                
                // Show Upload Workflow Steps
                stepUpload.style.display = 'inline-flex';
                stepImages.style.display = 'inline-flex';
                stepPublish.style.display = 'inline-flex';
                connector1.style.display = 'flex';
                connector2.style.display = 'flex';
                // Show step badge in import mode
                document.getElementById('step-publish-badge').style.display = 'flex';
                // Restore left padding for badge
                actionBtn.style.paddingLeft = '2.25rem';
                uploadBtn.style.display = 'inline-flex';
                uploadImagesBtn.style.display = 'inline-flex';
                actionBtn.innerText = "Publish All";
                actionBtn.onclick = downloadJSONL;
                
                // Reset workflow state
                resetWorkflowState();
            } else {
                badge.innerText = "LIBRARY MODE";
                badge.className = "badge-mode badge-library";
                activeData = libraryData;
                
                // Hide Upload Workflow Steps (show only save button, no step badge)
                stepUpload.style.display = 'none';
                stepImages.style.display = 'none';
                connector1.style.display = 'none';
                connector2.style.display = 'none';
                stepPublish.style.display = 'inline-flex';
                stepPublish.classList.remove('pending', 'completed', 'active');
                // Hide step badge in library mode
                document.getElementById('step-publish-badge').style.display = 'none';
                // Remove left padding since no badge
                actionBtn.style.paddingLeft = '1rem';
                uploadBtn.style.display = 'none';
                uploadImagesBtn.style.display = 'none';
                actionBtn.innerText = "Save Changes";
                actionBtn.disabled = false;
                actionBtn.onclick = () => alert("Changes saved to database!"); 
            }

            // 4. Reset Editor State
            activeIndex = null;
            document.getElementById('main-editor').classList.remove('active');
            document.getElementById('editor-wrapper').style.display = 'none';
            document.getElementById('empty-state').style.display = 'block';

            // 5. Render correct list
            renderList();
        }

        // --- FETCH (Library Mode) ---
        function fetchQuestions() {
            const grade = document.getElementById('filter-grade').value;
            const subject = document.getElementById('filter-subject').value;
            const chapter = document.getElementById('filter-chapter').value;
            
            // Reset
            libraryData = [];
            activeData = libraryData;
            renderList();

            setTimeout(() => {
                const filtered = mockDatabase.filter(q => {
                    const taxonomy = q.taxonomy || {};
                    const matchGrade = taxonomy.grade_id === grade;
                    const matchSubject = taxonomy.subject_id === subject;
                    const unitId = taxonomy.unit_id || '';
                    const matchChapter = chapter === 'all' ? true : unitId === chapter;
                    return matchGrade && matchSubject && matchChapter;
                });
                
                // Deep copy and ensure defaults
                libraryData = filtered.map(q => ensureSchemaDefaults(JSON.parse(JSON.stringify(q))));
                activeData = libraryData; // Update reference

                document.getElementById('library-count').innerText = `${libraryData.length} Items`;
                document.getElementById('library-status').innerText = libraryData.length > 0 ? "Ready" : "No Results";
                
                renderList();
            }, 300);
        }

        // --- FILE UPLOAD (Import Mode) ---
        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const newQuestions = parseMixedJson(content);
                
                if (newQuestions.length > 0) {
                    importData = newQuestions;
                    activeData = importData; // Switch reference
                    
                    document.getElementById('import-count').innerText = `${importData.length} Items`;
                    document.getElementById('import-status').innerText = "Loaded";
                    
                    // If we are in Library mode, switch to Import automatically to show results
                    if(activeWorkflow !== 'import') switchWorkflow('import');
                    else renderList();
                    
                    selectQuestion(0);
                    
                    // Update workflow animation - Step 1 completed
                    updateWorkflowState(1);
                } else {
                    alert('No valid JSON objects found.');
                }
            };
            reader.readAsText(file);
        });

        // --- IMAGE UPLOAD ---
        document.getElementById('image-files-input').addEventListener('change', function(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;

            let loadedCount = 0;
            let matchedCount = 0;
            const totalFiles = files.length;

            // Collect all image tags from loaded questions
            const allTags = collectAllImageTags();

            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(evt) {
                    const dataUrl = evt.target.result;
                    // Get filename without extension for matching
                    const fileName = file.name.replace(/\.[^/.]+$/, '');
                    
                    // Try to match with existing tags (partial match)
                    const matchedTag = findMatchingTag(fileName, allTags);
                    if (matchedTag) {
                        uploadedImages[matchedTag] = dataUrl;
                        matchedCount++;
                    } else {
                        // Store with filename as key for potential future matching
                        uploadedImages[fileName] = dataUrl;
                    }

                    loadedCount++;
                    
                    // When all files are loaded, refresh the preview
                    if (loadedCount === totalFiles) {
                        const uploadBtn = document.getElementById('btn-upload-images');
                        uploadBtn.innerHTML = `ðŸ–¼ï¸ Images (${Object.keys(uploadedImages).length})`;
                        
                        // Refresh preview if a question is selected
                        if (activeIndex !== null && activeData && activeData[activeIndex]) {
                            renderPrintPreview(activeData[activeIndex], activeIndex);
                        }
                        
                        // Update workflow animation - Step 2 completed
                        updateWorkflowState(2);
                        
                        // Show summary
                        alert(`Loaded ${totalFiles} image(s).\n${matchedCount} matched to question tags.`);
                    }
                };
                reader.readAsDataURL(file);
            });
            
            // Reset input to allow re-uploading same files
            e.target.value = '';
        });

        // Collect all [[image:tag]] references from loaded questions
        function collectAllImageTags() {
            const tags = new Set();
            const tagRegex = /\[\[image:([^\]]+)\]\]/g;
            
            if (!activeData) return tags;
            
            activeData.forEach(q => {
                const data = q.data || {};
                
                // Check common_content and content
                [data.common_content, data.content].forEach(text => {
                    if (text) {
                        let match;
                        while ((match = tagRegex.exec(text)) !== null) {
                            tags.add(match[1]);
                        }
                    }
                });
                
                // Check sub_questions
                if (data.sub_questions) {
                    data.sub_questions.forEach(sq => {
                        const sqData = sq.data || {};
                        if (sqData.content) {
                            let match;
                            while ((match = tagRegex.exec(sqData.content)) !== null) {
                                tags.add(match[1]);
                            }
                        }
                        // Check options
                        if (sqData.options) {
                            sqData.options.forEach(opt => {
                                if (opt.text) {
                                    let match;
                                    while ((match = tagRegex.exec(opt.text)) !== null) {
                                        tags.add(match[1]);
                                    }
                                }
                            });
                        }
                    });
                }
                
                // Check options for MCQ
                if (data.options) {
                    data.options.forEach(opt => {
                        if (opt.text) {
                            let match;
                            while ((match = tagRegex.exec(opt.text)) !== null) {
                                tags.add(match[1]);
                            }
                        }
                    });
                }
                
                // Check pairs for MATCH
                if (data.pairs) {
                    data.pairs.forEach(pair => {
                        [pair.left, pair.right].forEach(text => {
                            if (text) {
                                let match;
                                while ((match = tagRegex.exec(text)) !== null) {
                                    tags.add(match[1]);
                                }
                            }
                        });
                    });
                }
            });
            
            return tags;
        }

        // Find a tag that matches the filename (supports partial matching)
        function findMatchingTag(fileName, tags) {
            // Exact match first
            if (tags.has(fileName)) return fileName;
            
            // Try partial match - filename contains tag or tag contains filename
            for (const tag of tags) {
                if (tag.includes(fileName) || fileName.includes(tag)) {
                    return tag;
                }
            }
            
            // Try matching last part of tag (after last hyphen)
            for (const tag of tags) {
                const tagParts = tag.split('-');
                const lastPart = tagParts[tagParts.length - 1];
                if (lastPart === fileName || fileName.includes(lastPart)) {
                    return tag;
                }
            }
            
            return null;
        }

        // --- SHARED: RENDER LIST ---
        function renderList() {
            // Determine which container to use
            const containerId = activeWorkflow === 'import' ? 'import-list' : 'library-list';
            const listEl = document.getElementById(containerId);
            if(!listEl) return;
            
            listEl.innerHTML = '';
            
            if(!activeData || activeData.length === 0) {
                listEl.innerHTML = '<div style="padding:1rem; text-align:center; color:#999; font-size:0.8rem;">No questions loaded</div>';
                return;
            }

            activeData.forEach((q, idx) => {
                const item = document.createElement('div');
                item.className = `q-item ${idx === activeIndex ? 'active' : ''}`;
                item.onclick = () => selectQuestion(idx);
                
                const status = hasImages(q) 
                    ? '<span class="status-indicator pending"><span class="dot"></span> Has Assets</span>' 
                    : '<span class="status-indicator valid"><span class="dot"></span> Text Only</span>';

                // Read from v4.0 schema
                const meta = q.metadata || {};
                const data = q.data || {};
                
                const chap = meta.chapter ? `Ch ${meta.chapter}` : 'General';
                const sec = meta.section ? `Sec ${meta.section}` : '';
                
                const poolBadge = (meta.pool || '').toLowerCase() === 'exam' 
                    ? '<span style="font-size:0.65rem; background:#fef3c7; color:#92400e; padding:1px 4px; border-radius:3px; border:1px solid #fcd34d;">EXAM</span>'
                    : '<span style="font-size:0.65rem; background:#ecfdf5; color:#065f46; padding:1px 4px; border-radius:3px; border:1px solid #6ee7b7;">PRACTICE</span>';

                // Get preview text from data.content or data.common_content (for COMPOSITE)
                const contentText = data.content || data.common_content || '';
                // Strip image tokens for preview
                const promptText = contentText.replace(/\[\[image:[^\]]+\]\]/g, '[img]').substring(0, 100) || 'No content';

                item.innerHTML = `
                    <div class="q-item-header">
                        <span class="q-id">${q.id || `Q${idx + 1}`}</span>
                        <div style="display:flex; gap:4px; align-items:center;">
                            ${poolBadge}
                            <span style="font-size:0.7rem; background:#eee; padding:2px 6px; border-radius:4px;">${(meta.difficulty||'').toUpperCase()}</span>
                        </div>
                    </div>
                    <div class="q-location">${chap} â€¢ ${sec}</div>
                    <div class="q-preview">${promptText}</div>
                    ${status}
                `;
                listEl.appendChild(item);
            });
        }

        // --- SHARED: SELECT QUESTION ---
        function selectQuestion(idx) {
            activeIndex = idx;
            const q = activeData[idx]; // Use activeData reference
            
            renderList(); // Refresh highlighting

            // 1. Show the main editor pane
            document.getElementById('main-editor').classList.add('active');
            // 2. Force Show Wrapper
            document.getElementById('empty-state').style.display = 'none';
            document.getElementById('editor-wrapper').style.display = 'block';
            
            // Populate Fields
            populateEditor(q);
            
            // 2. Force Active Tab
            const isEditActive = document.getElementById('tab-edit').classList.contains('active');
            if (isEditActive) {
                 // Force Edit View
                 document.getElementById('tab-edit').classList.add('active');
                 document.getElementById('tab-preview').classList.remove('active');
                 
                 document.getElementById('view-edit').classList.add('active');
                 document.getElementById('view-preview').classList.remove('active');
                 
                 // Ensure controls enabled
                 const poolSelect = document.getElementById('meta-pool-type');
                 const diffSelect = document.getElementById('meta-difficulty');
                 const pointInput = document.getElementById('meta-points');
                 poolSelect.disabled = false;
                 diffSelect.disabled = false;
                 pointInput.disabled = false;
            } else {
                 // Default to Preview View
                 document.getElementById('view-preview').classList.add('active');
                 document.getElementById('view-edit').classList.remove('active');
                 renderPreview(q, idx);
            }
        }

        // New helper to avoid recursion
        function populateEditor(q) {
            // First, hide all optional sections to ensure clean state
            document.getElementById('stimulus-section').style.display = 'none';
            document.getElementById('options-section').style.display = 'none';
            document.getElementById('subquestions-section').style.display = 'none';
            document.getElementById('word-bank-section').style.display = 'none';
            document.getElementById('groups-section').style.display = 'none';
            document.getElementById('pairs-section').style.display = 'none';
            document.getElementById('table-editor-section').style.display = 'none';
            
            // Read from v4.0 schema structure
            const meta = q.metadata || {};
            const data = q.data || {};
            const solution = q.solution || {};
            const qType = q.type || 'SUBJECTIVE';
            
            document.getElementById('meta-id').innerText = q.id || `Q${activeIndex+1}`;
            document.getElementById('meta-type').value = qType;
            document.getElementById('meta-pool-type').value = (meta.pool || 'Practice').toLowerCase();
            document.getElementById('meta-difficulty').value = (meta.difficulty || 'Medium').toLowerCase();
            
            // Points - readonly for composite questions (total is sum of sub-questions)
            const pointsInput = document.getElementById('meta-points');
            const isComposite = (qType === 'COMPOSITE');
            pointsInput.value = meta.marks || '1';
            pointsInput.readOnly = isComposite;
            pointsInput.style.opacity = isComposite ? '0.6' : '1';
            pointsInput.style.cursor = isComposite ? 'not-allowed' : 'text';
            pointsInput.title = isComposite ? 'Total marks are calculated from sub-questions' : 'Points';
            
            // Location metadata
            document.getElementById('meta-grade').value = meta.grade || '';
            document.getElementById('meta-subject').value = meta.subject || '';
            document.getElementById('meta-unit').value = meta.chapter || '';
            document.getElementById('meta-section').value = meta.section || 'A';

            // Content from data - handle different types
            // For COMPOSITE, main content is common_content; for others, it's content
            const mainContent = data.common_content || data.content || '';
            document.getElementById('input-prompt').value = mainContent;
            // v4.0 uses [[image:tag]] tokens for images, not assets array
            renderAssetList([], 'prompt-assets', () => {});

            // Stimulus Section - v4.0 doesn't have separate stimulus
            // For COMPOSITE, common_content serves as stimulus
            const stimArea = document.getElementById('stimulus-section');
                stimArea.style.display = 'none';

            // Get question type for conditional rendering
            const isMcqType = qType === 'MCQ';
            const isFibType = qType === 'FIB';
            const isMatchType = qType === 'MATCH';
            const isCompositeType = qType === 'COMPOSITE';

            // Options Section (for MCQ type)
            const optionsSection = document.getElementById('options-section');
            const options = data.options;
            if(isMcqType && options && options.length > 0) {
                optionsSection.style.display = 'block';
                document.getElementById('options-section-label').textContent = 'OPTIONS (MCQ)';
                    renderMainOptions(options);
                // Set options layout toggle state (default to horizontal)
                updateOptionsLayoutButtons(data.style?.options_layout || 'horizontal');
                } else {
                optionsSection.style.display = 'none';
            }

            // FIB options_pool as word bank
            if(isFibType && data.options_pool && data.options_pool.length > 0) {
                document.getElementById('word-bank-section').style.display = 'block';
                document.getElementById('word-bank-label').textContent = 'WORD BANK (options_pool)';
                document.getElementById('word-bank-hint').textContent = 'Words available for fill-in-the-blank questions';
                renderWordBank(data.options_pool);
            }
            
            // COMPOSITE: Check for shared options_pool across FIB sub-questions
            if(isCompositeType && data.sub_questions) {
                const fibSubs = data.sub_questions.filter(sq => sq.type === 'FIB' && sq.data?.options_pool?.length > 0);
                if (fibSubs.length > 0) {
                    // Show word bank section for shared editing
                    document.getElementById('word-bank-section').style.display = 'block';
                    document.getElementById('word-bank-label').textContent = 'SHARED WORD BANK (options_pool)';
                    document.getElementById('word-bank-hint').textContent = 'Editing here updates all FIB sub-questions';
                    renderWordBank(fibSubs[0].data.options_pool);
                }
            }
            
            // MATCH pairs (v4.0 schema: data.pairs array with {left, right} objects)
            if(isMatchType) {
                document.getElementById('pairs-section').style.display = 'block';
                if (!data.pairs) data.pairs = [];
                renderMatchPairs(data.pairs);
            }
            
            // TABLE editor (v4.6)
            const isTableType = qType === 'TABLE';
            const tableSection = document.getElementById('table-editor-section');
            if(isTableType) {
                tableSection.style.display = 'block';
                renderTableEditor(data);
            } else {
                tableSection.style.display = 'none';
            }

            // Sub-Questions Section (only for COMPOSITE type)
            const subqSection = document.getElementById('subquestions-section');
            const subquestions = data.sub_questions;
            if(isCompositeType && subquestions && subquestions.length > 0) {
                subqSection.style.display = 'block';
            renderSubQuestions(q);
            } else {
                subqSection.style.display = 'none';
            }

            // Solution Section - populate with solution.text
            document.getElementById('input-solution').value = solution.text || '';

            // Update subquestions layout buttons (default to vertical)
            updateLayoutButtons(data.style?.sub_questions_layout || 'vertical');
            
            updateJsonView();
        }

        // Update visibility of "Add Section" buttons - removed in v4.0 UI
        function updateAddSectionButtons(q) {
            // No-op - Add Missing Sections bar has been removed
        }

        // --- UTILITY FUNCTIONS ---
        
        /**
         * Extract the display label from an ID
         * Returns the part after the last hyphen, or the full ID if no hyphen
         * e.g., "Q1-a" â†’ "a", "Q1-sub-b" â†’ "b", "abc" â†’ "abc"
         */
        function getIdDisplayLabel(id) {
            if (!id) return '';
            const parts = id.split('-');
            return parts[parts.length - 1];
        }

        // --- DATA HELPERS (Adapted for v4.0 schema) ---
        function updatePrompt(val) {
            const q = activeData[activeIndex];
            if (!q.data) q.data = {};
            // For COMPOSITE, update common_content; for others, update content
            if (q.type === 'COMPOSITE') {
                q.data.common_content = val;
            } else {
                q.data.content = val;
            }
            renderList();
            updateJsonView(); 
        }

        function updateSolution(val) {
            const q = activeData[activeIndex];
            if (!q.solution) q.solution = {};
            q.solution.text = val;
            updateJsonView();
        }

        // v4.8: Image size drag controls - dimensions stored in tag [[image:id|height:H|width:W]]
        let isResizing = false;
        let resizeStartX = 0;
        let resizeStartY = 0;
        let resizeStartWidth = 0;
        let resizeStartHeight = 0;
        let resizeDirection = '';
        let resizeTarget = null;
        let resizeContainer = null;
        let resizeImageTag = ''; // Store the original tag being resized
        
        // Parse image tag to extract id and dimensions
        // Format: [[image:id]] or [[image:id|height:H|width:W]]
        // The tag passed here is the content inside [[ ]], e.g., "image:id|height:50|width:75"
        function parseImageTag(tag) {
            // Remove 'image:' prefix if present
            let cleanTag = tag;
            if (tag.startsWith('image:')) {
                cleanTag = tag.substring(6);
            }
            const parts = cleanTag.split('|');
            const result = { id: parts[0], width: null, height: null };
            
            for (let i = 1; i < parts.length; i++) {
                const part = parts[i].trim();
                if (part.startsWith('width:')) {
                    result.width = parseInt(part.substring(6));
                } else if (part.startsWith('height:')) {
                    result.height = parseInt(part.substring(7));
                }
            }
            return result;
        }
        
        // Build image tag with dimensions
        // Format: [[image:id|height:H|width:W]]
        function buildImageTag(id, width, height) {
            let tag = id;
            if (height) tag += `|height:${Math.round(height)}`;
            if (width) tag += `|width:${Math.round(width)}`;
            return `[[image:${tag}]]`;
        }
        
        // Update image tag in content with new dimensions
        function updateImageTagInContent(imageId, width, height) {
            if (activeIndex < 0 || !activeData[activeIndex]) {
                console.warn('No active question to update image tag');
                return;
            }
            
            const q = activeData[activeIndex];
            if (!q.data) return;
            
            // Regex to find image tags with this ID (with or without dimensions) - format: [[image:id...]]
            const tagRegex = new RegExp(`\\[\\[image:${escapeRegex(imageId)}(\\|[^\\]]*)?\\]\\]`, 'g');
            const newTag = buildImageTag(imageId, width, height);
            
            // Update content field
            if (q.data.content) {
                q.data.content = q.data.content.replace(tagRegex, newTag);
            }
            
            // Update common_content for COMPOSITE
            if (q.data.common_content) {
                q.data.common_content = q.data.common_content.replace(tagRegex, newTag);
            }
            
            // Update options for MCQ
            if (q.data.options) {
                q.data.options.forEach(opt => {
                    if (opt.text) {
                        opt.text = opt.text.replace(tagRegex, newTag);
                    }
                });
            }
            
            // Update pairs for MATCH
            if (q.data.pairs) {
                q.data.pairs.forEach(pair => {
                    if (pair.left) pair.left = pair.left.replace(tagRegex, newTag);
                    if (pair.right) pair.right = pair.right.replace(tagRegex, newTag);
                });
            }
            
            // Update sub_questions for COMPOSITE
            if (q.data.sub_questions) {
                q.data.sub_questions.forEach(sq => {
                    if (sq.data?.content) {
                        sq.data.content = sq.data.content.replace(tagRegex, newTag);
                    }
                    if (sq.data?.options) {
                        sq.data.options.forEach(opt => {
                            if (opt.text) {
                                opt.text = opt.text.replace(tagRegex, newTag);
                            }
                        });
                    }
                });
            }
            
            // Update JSON view and list
            updateJsonView();
            renderList();
            
            // Also update the prompt textarea if in edit mode
            const promptInput = document.getElementById('input-prompt');
            if (promptInput && q.type === 'COMPOSITE') {
                promptInput.value = q.data.common_content || '';
            } else if (promptInput) {
                promptInput.value = q.data.content || '';
            }
        }
        
        // Helper to escape regex special characters
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // Clear image dimensions from tag
        function clearImageSize(imageId) {
            if (activeIndex < 0 || !activeData[activeIndex]) return;
            
            const q = activeData[activeIndex];
            if (!q.data) return;
            
            // Regex to find image tags with this ID
            const tagRegex = new RegExp(`\\[\\[image:${escapeRegex(imageId)}(\\|[^\\]]*)?\\]\\]`, 'g');
            const newTag = `[[image:${imageId}]]`; // Tag without dimensions
            
            // Update all content fields
            if (q.data.content) {
                q.data.content = q.data.content.replace(tagRegex, newTag);
            }
            if (q.data.common_content) {
                q.data.common_content = q.data.common_content.replace(tagRegex, newTag);
            }
            if (q.data.options) {
                q.data.options.forEach(opt => {
                    if (opt.text) opt.text = opt.text.replace(tagRegex, newTag);
                });
            }
            if (q.data.pairs) {
                q.data.pairs.forEach(pair => {
                    if (pair.left) pair.left = pair.left.replace(tagRegex, newTag);
                    if (pair.right) pair.right = pair.right.replace(tagRegex, newTag);
                });
            }
            if (q.data.sub_questions) {
                q.data.sub_questions.forEach(sq => {
                    if (sq.data?.content) {
                        sq.data.content = sq.data.content.replace(tagRegex, newTag);
                    }
                    if (sq.data?.options) {
                        sq.data.options.forEach(opt => {
                            if (opt.text) opt.text = opt.text.replace(tagRegex, newTag);
                        });
                    }
                });
            }
            
            updateJsonView(); 
            renderList();
            refreshPreviewIfVisible();
        }
        
        function initImageResize(e, direction, container) {
            e.preventDefault();
            e.stopPropagation();
            
            // Ensure we have an active question
            if (activeIndex < 0 || !activeData[activeIndex]) {
                console.warn('No active question for resize');
                return;
            }
            
            isResizing = true;
            resizeDirection = direction;
            resizeContainer = container;
            resizeTarget = container.querySelector('img');
            resizeImageTag = container.dataset.tag || ''; // Get the image tag/id
            resizeStartX = e.clientX;
            resizeStartY = e.clientY;
            resizeStartWidth = resizeTarget.offsetWidth;
            resizeStartHeight = resizeTarget.offsetHeight;
            
            // Lock container dimensions to prevent text reflow during resize
            container.style.width = container.offsetWidth + 'px';
            container.style.height = container.offsetHeight + 'px';
            container.style.overflow = 'visible';
            
            container.classList.add('resizing');
            document.addEventListener('mousemove', handleImageResize);
            document.addEventListener('mouseup', stopImageResize);
        }
        
        function handleImageResize(e) {
            if (!isResizing || !resizeTarget) return;
            
            const deltaX = e.clientX - resizeStartX;
            const deltaY = e.clientY - resizeStartY;
            
            let newWidth = resizeStartWidth;
            let newHeight = resizeStartHeight;
            
            if (resizeDirection === 'se' || resizeDirection === 'e') {
                newWidth = Math.max(50, resizeStartWidth + deltaX);
            }
            if (resizeDirection === 'se' || resizeDirection === 's') {
                newHeight = Math.max(50, resizeStartHeight + deltaY);
            }
            
            // Maintain aspect ratio for corner resize
            if (resizeDirection === 'se') {
                const aspectRatio = resizeStartWidth / resizeStartHeight;
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    newHeight = newWidth / aspectRatio;
                } else {
                    newWidth = newHeight * aspectRatio;
                }
            }
            
            resizeTarget.style.width = Math.round(newWidth) + 'px';
            resizeTarget.style.height = Math.round(newHeight) + 'px';
            
            // Update tooltip with current dimensions
            const tooltip = resizeContainer.querySelector('.size-tooltip');
            if (tooltip) {
                tooltip.textContent = `${Math.round(newWidth)} Ã— ${Math.round(newHeight)}`;
            }
        }
        
        function stopImageResize() {
            if (isResizing && resizeTarget && resizeImageTag) {
                const finalWidth = Math.round(resizeTarget.offsetWidth);
                const finalHeight = Math.round(resizeTarget.offsetHeight);
                
                // Parse the tag to get just the ID (without any existing dimensions)
                const parsed = parseImageTag(resizeImageTag);
                
                // Update the image tag in content with new dimensions
                updateImageTagInContent(parsed.id, finalWidth, finalHeight);
                
                // Release the locked container dimensions
                resizeContainer.style.width = '';
                resizeContainer.style.height = '';
                resizeContainer.style.overflow = '';
                
                resizeContainer.classList.remove('resizing');
                
                // Update the tooltip to show final size with checkmark
                const tooltip = resizeContainer.querySelector('.size-tooltip');
                if (tooltip) {
                    tooltip.textContent = `${finalWidth} Ã— ${finalHeight} âœ“`;
                }
            }
            
            // Also release dimensions if resize was cancelled
            if (resizeContainer) {
                resizeContainer.style.width = '';
                resizeContainer.style.height = '';
                resizeContainer.style.overflow = '';
            }
            
            isResizing = false;
            resizeTarget = null;
            resizeContainer = null;
            resizeImageTag = '';
            document.removeEventListener('mousemove', handleImageResize);
            document.removeEventListener('mouseup', stopImageResize);
        }
        
        function resetImageSize(e, imageId) {
            e.preventDefault();
            e.stopPropagation();
            clearImageSize(imageId);
        }

        function insertImageTag(inputId) {
            const textarea = document.getElementById(inputId);
            if (!textarea) return;
            
            const imageId = prompt('Enter Image ID (e.g., Q1.content.1):', '');
            if (!imageId || !imageId.trim()) return;
            
            const tag = `[[image:${imageId.trim()}]]`;
            
            // Insert at cursor position
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;
            
            textarea.value = text.substring(0, start) + tag + text.substring(end);
            
            // Move cursor after the inserted tag
            textarea.selectionStart = textarea.selectionEnd = start + tag.length;
            textarea.focus();
            
            // Trigger input event to update the data
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
        }

        function updateMeta(field, val) {
            const q = activeData[activeIndex];
            // Ensure nested structures exist for v4.0 schema
            if (!q.metadata) q.metadata = {};
            if (!q.data) q.data = {};
            if (!q.solution) q.solution = { text: '' };
            
            if(field === 'pool_type') {
                q.metadata.pool = val.charAt(0).toUpperCase() + val.slice(1); // Capitalize
            } else if(field === 'points') {
                // For composite questions, points are calculated from sub-questions
                if (q.type === 'COMPOSITE') {
                    recalculateTotalMarks();
                    return;
                }
                q.metadata.marks = parseInt(val) || 1;
            } else if(field === 'grade_id') {
                q.metadata.grade = val;
            } else if(field === 'subject_id') {
                q.metadata.subject = val;
            } else if(field === 'unit_id') {
                q.metadata.chapter = val;
            } else if(field === 'section_id') {
                q.metadata.section = val;
            } else if(field === 'difficulty') {
                q.metadata.difficulty = val.charAt(0).toUpperCase() + val.slice(1); // Capitalize
            } else if(field === 'type') {
                const oldType = q.type;
                q.type = val;
                
                const isMcqType = val === 'MCQ';
                const isCompositeType = val === 'COMPOSITE';
                const isMatchType = val === 'MATCH';
                const isTableType = val === 'TABLE';
                
                // Auto-add options for MCQ type
                if(isMcqType && !q.data.options) {
                    q.data.options = [
                        { id: 'a', text: 'Option A' },
                        { id: 'b', text: 'Option B' }
                    ];
                }
                
                // Auto-add pairs for MATCH type
                if(isMatchType && !q.data.pairs) {
                    q.data.pairs = [
                        { left: 'Item A', right: 'Match A' }
                    ];
                }
                
                // Auto-add rows/columns for TABLE type (v4.5)
                if(isTableType) {
                    if(!q.data.rows || q.data.rows.length === 0) {
                        q.data.rows = [
                            { id: 'r1', text: 'Row 1' },
                            { id: 'r2', text: 'Row 2' }
                        ];
                    }
                    if(!q.data.columns || q.data.columns.length === 0) {
                        q.data.columns = [
                            { id: 'c1', text: 'Column 1' },
                            { id: 'c2', text: 'Column 2' }
                        ];
                    }
                    // Ensure TableStyle with table_grid_lines and hide_header
                    if(!q.data.style) q.data.style = {};
                    if(!q.data.style.table_grid_lines) {
                        q.data.style.table_grid_lines = 'all';
                    }
                    if(!q.data.style.hide_header) {
                        q.data.style.hide_header = 'none';
                    }
                }
                
                // Remove options for types that don't use them
                if(!isMcqType && q.data.options && q.data.options.length > 0) {
                    if(confirm('Changing to this type will remove the Options section. Continue?')) {
                        delete q.data.options;
            } else {
                        q.type = oldType; // Revert
                        document.getElementById('meta-type').value = oldType;
                        return;
                    }
                }
                
                // Auto-add sub_questions for COMPOSITE type if not present
                if(isCompositeType && !q.data.sub_questions) {
                    q.data.sub_questions = [
                        { id: 'a', type: 'SUBJECTIVE', data: { content: '' } }
                    ];
                }
                
                // Remove sub_questions for non-composite types
                if(!isCompositeType && q.data.sub_questions && q.data.sub_questions.length > 0) {
                    if(confirm('Changing to this type will remove the Sub-Questions section. Continue?')) {
                        delete q.data.sub_questions;
                    } else {
                        q.type = oldType; // Revert
                        document.getElementById('meta-type').value = oldType;
                        return;
                    }
                }
                
                // Remove rows/columns for non-table types
                if(!isTableType && (q.data.rows || q.data.columns)) {
                    if(confirm('Changing to this type will remove the Table structure (rows/columns). Continue?')) {
                        delete q.data.rows;
                        delete q.data.columns;
                        // Remove table-specific styles
                        if(q.data.style) {
                            delete q.data.style.table_grid_lines;
                            delete q.data.style.hide_header;
                        }
                    } else {
                        q.type = oldType; // Revert
                        document.getElementById('meta-type').value = oldType;
                        return;
                    }
                }
                
                // For composite type, grading at root is read-only aggregate
                if(isCompositeType) {
                    // Points will be calculated from sub-questions
                }
                
                selectQuestion(activeIndex); // Refresh to show/hide relevant sections
                return;
            } else {
                // Generic field update - check if it's taxonomy or other
                if (['grade_id', 'subject_id', 'unit_id', 'section_id', 'type', 'difficulty', 'pool'].includes(field)) {
                    q.taxonomy[field] = val;
            } else {
                q[field] = val;
                }
            }
            renderList();
            updateJsonView(); 
        }

        function updateStimulus(val) {
            // v4.0 doesn't have separate stimulus - content is inline
            // No-op for v4.0
            updateJsonView(); 
        }
        
        function addAssetToPrompt() {
            // v4.0 uses [[image:tag]] tokens, not assets array
            // No-op - user should add [[image:tag]] token manually
            alert('In v4.0 schema, add images by typing [[image:tag]] tokens in the content.');
        }

        function addAssetToStimulus() {
            const q = activeData[activeIndex];
            // v4.0 uses [[image:tag]] tokens, not assets array
            alert('In v4.0 schema, add images by typing [[image:tag]] tokens in the content.');
        }

        function distributeTotalMarks(newTotal) {
            const q = activeData[activeIndex];
            const subquestions = q.data?.sub_questions;
            if(!subquestions || subquestions.length === 0) return;
            const count = subquestions.length;
            const newPerSub = Math.round((newTotal / count) * 100) / 100; 
            // v4.0 doesn't have per-subquestion marks in the same way
            renderSubQuestions(q);
            updateJsonView();
        }

        function recalculateTotalMarks() {
            const q = activeData[activeIndex];
            // v4.0 uses metadata.marks for total marks
            // For COMPOSITE, we could sum sub-question marks if they were tracked
            if (!q.metadata) q.metadata = {};
            // Just keep the current marks value
            const total = q.metadata.marks || 1;
            document.getElementById('meta-points').value = total;
            updateJsonView(); 
        }
        
        function setLayout(mode) {
            const q = activeData[activeIndex];
            if (!q.data) q.data = {};
            if (!q.data.style) q.data.style = {};
            q.data.style.sub_questions_layout = mode;
            updateLayoutButtons(mode);
            renderSubQuestions(q);
            updateJsonView(); 
            
            // Also re-render preview if it's visible
            const previewContainer = document.getElementById('view-preview');
            if (previewContainer.classList.contains('active')) {
                renderPreview(q, activeIndex);
            }
        }
        
        // Set layout for main-level options (MCQ)
        function setOptionsLayoutMain(mode) {
            const q = activeData[activeIndex];
            if (!q.data) q.data = {};
            if (!q.data.style) q.data.style = {};
            q.data.style.options_layout = mode;
            updateOptionsLayoutButtons(mode);
            updateJsonView();
            
            // Re-render preview if it's visible
            const previewContainer = document.getElementById('view-preview');
            if (previewContainer.classList.contains('active')) {
                renderPreview(q, activeIndex);
            }
        }
        
        function updateOptionsLayoutButtons(mode) {
            const vertBtn = document.getElementById('btn-options-layout-vertical');
            const horizBtn = document.getElementById('btn-options-layout-horizontal');
            if (vertBtn && horizBtn) {
                vertBtn.classList.toggle('active', mode === 'vertical');
                horizBtn.classList.toggle('active', mode === 'horizontal');
            }
        }

        // Set layout for individual sections - now only used for sub-questions
        function setSectionLayout(section, mode) {
            // Layout toggles have been removed from prompt, stimulus, options
            // This function is kept for potential future use
            updateJsonView();
        }
        
        function deleteQuestion() {
            if(!confirm('Are you sure you want to delete this question?')) return;
            activeData.splice(activeIndex, 1);
            
            // Clear the preview content to prevent stale data
            document.getElementById('a4-content').innerHTML = '';
            
            if(activeData.length > 0) {
                selectQuestion(0);
            } else {
                // No questions left - reset editor state
                document.getElementById('main-editor').classList.remove('active');
                document.getElementById('editor-wrapper').style.display = 'none';
                document.getElementById('empty-state').style.display = 'block';
                
                // Reset to Preview tab so next question opens in preview mode (default view)
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('tab-preview').classList.add('active');
                document.querySelectorAll('.edit-view-container, .preview-view-container').forEach(v => v.classList.remove('active'));
                document.getElementById('view-preview').classList.add('active');
                
                // Clear JSON view as well
                document.getElementById('json-ro-textarea').value = '';
            }
            renderList();
            // Update counts
            if(activeWorkflow === 'import') {
                document.getElementById('import-count').innerText = `${importData.length} Items`;
            } else {
                document.getElementById('library-count').innerText = `${libraryData.length} Items`;
            }
        }


        function updateJsonView() {
            const q = activeData[activeIndex];
            if (q) {
                document.getElementById('json-ro-textarea').value = JSON.stringify(q, null, 2);
                // Also update layout JSON if that view is active
                const layoutView = document.getElementById('sub-view-layout');
                if (layoutView && layoutView.style.display !== 'none') {
                    updateLayoutJsonView();
                }
            }
        }

        // NOTE: getTextValue is now in question-parser.js

        // =====================================================
        // REMOVE SECTION FUNCTIONS
        // =====================================================
        
        function removeSection(sectionName) {
            const q = activeData[activeIndex];
            if(confirm(`Are you sure you want to remove the ${sectionName} section?`)) {
                // Handle v4.0 schema data sections
                if (['stimulus', 'options', 'subquestions', 'sub_questions'].includes(sectionName)) {
                    if (q.data) {
                        delete q.data[sectionName];
                    }
                } else {
                delete q[sectionName];
                }
                selectQuestion(activeIndex);
            }
        }

        // =====================================================
        // OPTIONS MANAGEMENT (Main Level)
        // =====================================================
        
        function renderMainOptions(options) {
            const container = document.getElementById('options-list');
            container.innerHTML = '';
            
            options.forEach((opt, idx) => {
                // Support both opt_id (new schema) and id (legacy schema)
                // Display only the part after the last hyphen for cleaner display
                const rawId = opt.opt_id || opt.id || `${String.fromCharCode(97 + idx)}`;
                const optId = getIdDisplayLabel(rawId);
                const optText = getTextValue(opt);
                const optAssets = (typeof opt === 'object' && opt.assets) ? opt.assets : [];
                
                const item = document.createElement('div');
                item.className = 'option-item';
                item.style.flexWrap = 'wrap';
                item.style.alignItems = 'flex-start';
                
                // Create text/input section
                const textSection = document.createElement('div');
                textSection.style.display = 'flex';
                textSection.style.alignItems = 'center';
                textSection.style.gap = '0.5rem';
                textSection.style.flex = '1';
                textSection.style.minWidth = '0';
                textSection.innerHTML = `
                    <span class="option-id">${optId}</span>
                    <input type="text" value="${optText}" placeholder="Enter text..." 
                           oninput="updateOption(${idx}, this.value)" style="flex:1;">
                    <div class="option-actions">
                        <button class="btn btn-sm" onclick="addOptionMedia(${idx})">ðŸ–¼ï¸</button>
                        <button class="btn btn-sm delete-sub-btn" onclick="deleteOption(${idx})">âœ•</button>
                    </div>
                `;
                item.appendChild(textSection);
                container.appendChild(item);
                
                // Create assets section below the option (stack layout only)
                if (optAssets.length > 0) {
                    const assetSection = document.createElement('div');
                    assetSection.className = 'asset-container';
                    assetSection.style.width = '100%';
                    assetSection.style.marginLeft = '50px';
                    assetSection.style.marginTop = '0.5rem';
                    assetSection.style.marginBottom = '0.5rem';
                    
                    renderAssetList(optAssets, assetSection, (newAssets) => {
                        activeData[activeIndex].content.options[idx].assets = newAssets;
                        updateJsonView();
                    });
                    
                    container.appendChild(assetSection);
                }
            });
        }

        function addOption() {
            const q = activeData[activeIndex];
            if (!q.data) q.data = {};
            if(!q.data.options) q.data.options = [];
            const newIdx = q.data.options.length;
            const newId = String.fromCharCode(97 + newIdx);
            q.data.options.push({ id: newId, text: '' });
            renderMainOptions(q.data.options);
            updateJsonView();
        }

        function updateOption(idx, value) {
            const q = activeData[activeIndex];
            const opt = q.data?.options?.[idx];
            if (!opt) return;
            if(typeof opt === 'string') {
                q.data.options[idx] = { id: String.fromCharCode(97 + idx), text: value };
            } else {
                q.data.options[idx].text = value;
            }
            updateJsonView();
        }

        function deleteOption(idx) {
            const q = activeData[activeIndex];
            if (q.data?.options) {
                q.data.options.splice(idx, 1);
                renderMainOptions(q.data.options);
            }
            updateJsonView();
        }

        function addOptionMedia(idx) {
            // v4.0 uses [[image:tag]] tokens in option text, not assets array
            alert('In v4.0 schema, add images by typing [[image:tag]] tokens in the option text.');
        }

        // =====================================================
        // WORD BANK MANAGEMENT (v4.0 uses options_pool for FIB)
        // =====================================================
        
        function toggleWordBank() {
            const q = activeData[activeIndex];
            // v4.0 FIB uses data.options_pool, COMPOSITE uses shared pool across FIB sub-questions
            if (q.type !== 'FIB' && q.type !== 'COMPOSITE') return;
            
            const section = document.getElementById('word-bank-section');
            if(section.style.display === 'none') {
                section.style.display = 'block';
                if (!q.data) q.data = {};
                
                if (q.type === 'FIB') {
                    if(!q.data.options_pool) q.data.options_pool = [];
                    if(q.data.options_pool.length === 0) {
                        addWordBankItem();
                    }
                } else if (q.type === 'COMPOSITE' && q.data.sub_questions) {
                    // Initialize options_pool for all FIB sub-questions
                    const fibSubs = q.data.sub_questions.filter(sq => sq.type === 'FIB');
                    if (fibSubs.length > 0) {
                        fibSubs.forEach(sq => {
                            if (!sq.data) sq.data = {};
                            if (!sq.data.options_pool) sq.data.options_pool = [];
                        });
                        // If all empty, add one item
                        if (fibSubs[0].data.options_pool.length === 0) {
                            addWordBankItem();
                        } else {
                            renderWordBank(fibSubs[0].data.options_pool);
                        }
                    }
                }
            } else {
                section.style.display = 'none';
            }
        }

        // v4.0: Render options_pool (word bank) for FIB type
        // For COMPOSITE with shared pool, renders the shared editor
        function renderWordBank(optionsPool) {
            const container = document.getElementById('word-bank-list');
            container.innerHTML = '';
            
            optionsPool.forEach((word, idx) => {
                const el = document.createElement('div');
                el.className = 'word-bank-item';
                el.innerHTML = `
                    <input type="text" value="${word || ''}" placeholder="Word ${idx + 1}..." 
                           oninput="updateWordBankItem(${idx}, this.value)">
                    <button class="delete-btn" onclick="deleteWordBankItem(${idx})" title="Remove word">âœ•</button>
                `;
                container.appendChild(el);
            });
        }

        // v4.0: Add word to options_pool
        function addWordBankItem() {
            const q = activeData[activeIndex];
            if (!q.data) q.data = {};
            
            // For FIB type
            if (q.type === 'FIB') {
                if (!q.data.options_pool) q.data.options_pool = [];
                q.data.options_pool.push('');
                renderWordBank(q.data.options_pool);
            }
            // For COMPOSITE type - add to all FIB sub-questions
            else if (q.type === 'COMPOSITE' && q.data.sub_questions) {
                q.data.sub_questions.forEach(sq => {
                    if (sq.type === 'FIB') {
                        if (!sq.data) sq.data = {};
                        if (!sq.data.options_pool) sq.data.options_pool = [];
                        sq.data.options_pool.push('');
                    }
                });
                // Render the shared pool (use first FIB sub-question's pool)
                const firstFib = q.data.sub_questions.find(sq => sq.type === 'FIB' && sq.data?.options_pool);
                if (firstFib) renderWordBank(firstFib.data.options_pool);
            }
            
            document.getElementById('word-bank-section').style.display = 'block';
            updateJsonView();
            renderPreview(q, activeIndex);
        }

        // v4.0: Update word in options_pool
        function updateWordBankItem(idx, value) {
            const q = activeData[activeIndex];
            
            // For FIB type
            if (q.type === 'FIB' && q.data?.options_pool) {
                q.data.options_pool[idx] = value;
            }
            // For COMPOSITE type - update all FIB sub-questions' options_pool
            else if (q.type === 'COMPOSITE' && q.data?.sub_questions) {
                q.data.sub_questions.forEach(sq => {
                    if (sq.type === 'FIB' && sq.data?.options_pool) {
                        sq.data.options_pool[idx] = value;
                    }
                });
            }
            
            updateJsonView();
            renderPreview(q, activeIndex);
        }

        // v4.0: Delete word from options_pool
        function deleteWordBankItem(idx) {
            const q = activeData[activeIndex];
            
            // For FIB type
            if (q.type === 'FIB' && q.data?.options_pool) {
                q.data.options_pool.splice(idx, 1);
                renderWordBank(q.data.options_pool);
            }
            // For COMPOSITE type - delete from all FIB sub-questions
            else if (q.type === 'COMPOSITE' && q.data?.sub_questions) {
                q.data.sub_questions.forEach(sq => {
                    if (sq.type === 'FIB' && sq.data?.options_pool) {
                        sq.data.options_pool.splice(idx, 1);
                    }
                });
                // Render the shared pool (use first FIB sub-question's pool)
                const firstFib = q.data.sub_questions.find(sq => sq.type === 'FIB' && sq.data?.options_pool);
                if (firstFib) renderWordBank(firstFib.data.options_pool);
            }
            
            updateJsonView();
            renderPreview(q, activeIndex);
        }

        // =====================================================
        // GROUPS MANAGEMENT (for sorting/classification)
        // =====================================================
        
        function toggleGroups() {
            const q = activeData[activeIndex];
            const stimulus = q.content?.stimulus;
            if(!stimulus) return;
            
            const section = document.getElementById('groups-section');
            if(section.style.display === 'none') {
                section.style.display = 'block';
                if(!stimulus.groups) stimulus.groups = [];
                if(stimulus.groups.length === 0) {
                    addGroupItem();
                }
            } else {
                section.style.display = 'none';
            }
        }

        function renderGroups(groups) {
            const container = document.getElementById('groups-list');
            container.innerHTML = '';
            
            groups.forEach((item, idx) => {
                const el = document.createElement('div');
                el.className = 'groups-item';
                el.innerHTML = `
                    <input type="text" class="group-id" value="${item.group_id || ''}" placeholder="ID" 
                           oninput="updateGroupItem(${idx}, 'group_id', this.value)">
                    <input type="text" class="group-text" value="${item.text || ''}" placeholder="Category name..." 
                           oninput="updateGroupItem(${idx}, 'text', this.value)">
                    <button class="btn btn-sm delete-sub-btn" onclick="deleteGroupItem(${idx})">âœ•</button>
                `;
                container.appendChild(el);
            });
        }

        function addGroupItem() {
            const q = activeData[activeIndex];
            const stimulus = q.content?.stimulus;
            if(!stimulus) return;
            if(!stimulus.groups) stimulus.groups = [];
            const newIdx = stimulus.groups.length;
            stimulus.groups.push({ group_id: String.fromCharCode(97 + newIdx), text: '' });
            renderGroups(stimulus.groups);
            document.getElementById('groups-section').style.display = 'block';
            updateJsonView();
        }

        function updateGroupItem(idx, field, value) {
            const q = activeData[activeIndex];
            const stimulus = q.content?.stimulus;
            if (stimulus?.groups?.[idx]) {
                stimulus.groups[idx][field] = value;
            }
            updateJsonView();
        }

        function deleteGroupItem(idx) {
            const q = activeData[activeIndex];
            const stimulus = q.content?.stimulus;
            if (stimulus?.groups) {
                stimulus.groups.splice(idx, 1);
                renderGroups(stimulus.groups);
            }
            updateJsonView();
        }

        // =====================================================
        // PAIRS MANAGEMENT (v4.0 schema: data.pairs array with {left, right} objects)
        // =====================================================
        
        // Render match pairs in the edit view
        function renderMatchPairs(pairs) {
            const container = document.getElementById('pairs-list');
            container.innerHTML = '';
            
            if (!pairs || pairs.length === 0) {
                container.innerHTML = '<p style="font-size:0.8rem; color:#7c3aed; font-style:italic;">No pairs yet. Click "+ Add Pair" to create one.</p>';
                return;
            }
            
            pairs.forEach((pair, idx) => {
                const el = document.createElement('div');
                el.className = 'pair-item';
                el.innerHTML = `
                    <span class="pair-num">${idx + 1}.</span>
                    <input type="text" value="${pair.left || ''}" placeholder="Column A item..." 
                           oninput="updateMatchPair(${idx}, 'left', this.value)">
                    <span class="pair-arrow">â†”</span>
                    <input type="text" value="${pair.right || ''}" placeholder="Column B item..." 
                           oninput="updateMatchPair(${idx}, 'right', this.value)">
                    <button class="delete-btn" onclick="deleteMatchPair(${idx})" title="Remove pair">âœ•</button>
                `;
                container.appendChild(el);
            });
        }

        // Add a new match pair
        function addMatchPair() {
            const q = activeData[activeIndex];
            if (!q.data) q.data = {};
            if (!q.data.pairs) q.data.pairs = [];
            
            q.data.pairs.push({ left: '', right: '' });
            renderMatchPairs(q.data.pairs);
            document.getElementById('pairs-section').style.display = 'block';
            updateJsonView();
            renderPreview(q, activeIndex);
        }

        // Update a match pair field
        function updateMatchPair(idx, field, value) {
            const q = activeData[activeIndex];
            if (q.data?.pairs?.[idx]) {
                q.data.pairs[idx][field] = value;
            }
            updateJsonView();
            renderPreview(q, activeIndex);
        }

        // Delete a match pair
        function deleteMatchPair(idx) {
            const q = activeData[activeIndex];
            if (q.data?.pairs) {
                q.data.pairs.splice(idx, 1);
                renderMatchPairs(q.data.pairs);
            }
            updateJsonView();
            renderPreview(q, activeIndex);
        }

        // =====================================================
        // TABLE EDITOR MANAGEMENT (v4.5)
        // =====================================================
        
        // =====================================================
        // TABLE EDITOR FUNCTIONS (v4.6 schema)
        // table.header: optional array of RichText (column headers)
        // table.rows: required 2D array of RichText (cells)
        // =====================================================
        
        function renderTableEditor(data) {
            const container = document.getElementById('table-grid-editor');
            if (!container) return;
            
            // Ensure table structure exists
            if (!data.table) {
                data.table = { rows: [['', ''], ['', '']] };
            }
            
            const table = data.table;
            const header = table.header || [];
            const rows = table.rows || [];
            const numCols = Math.max(header.length, rows.length > 0 ? rows[0].length : 2);
            
            // v4.9: Get column widths from style
            const style = data.style || {};
            const columnWidths = style.column_widths || [];
            
            // Build editable table HTML
            let html = '<table class="table-grid-editor" id="table-editor-table">';
            
            // Colgroup for column widths
            html += '<colgroup>';
            html += '<col style="width:40px;">'; // Corner/row-actions column
            for (let c = 0; c < numCols; c++) {
                const colWidth = columnWidths[c] || '';
                html += `<col data-col="${c}" ${colWidth ? `style="width:${colWidth}"` : ''}>`;
            }
            html += '<col style="width:50px;">'; // Actions column
            html += '</colgroup>';
            
            // Header row (if exists)
            html += '<thead><tr>';
            html += '<th class="corner-cell"></th>'; // Corner cell
            for (let c = 0; c < numCols; c++) {
                const headerVal = header[c] || '';
                const colWidth = columnWidths[c] || '';
                const isLastDataCol = c === numCols - 1;
                // Display width as percentage or "auto"
                const widthDisplay = colWidth ? colWidth : 'auto';
                html += `<th class="resizable" data-col="${c}">
                    <div class="header-cell">
                        <input type="text" class="header-input" value="${escapeHtml(headerVal)}" 
                            placeholder="Header ${c + 1}"
                            onchange="updateTableHeader(${c}, this.value)" />
                    </div>
                    ${!isLastDataCol ? `<div class="col-resize-handle" data-col="${c}" onmousedown="initColResize(event, ${c})"></div>` : ''}
                    <div class="col-width-indicator">${widthDisplay}</div>
                </th>`;
            }
            html += '<th class="col-actions"><button class="btn-delete-col" onclick="deleteTableColumn()" title="Delete last column">âˆ’Col</button></th>';
            html += '</tr></thead>';
            
            // Data rows
            html += '<tbody>';
            rows.forEach((row, r) => {
                html += '<tr>';
                html += `<td class="row-actions"><button class="btn-delete-row" onclick="deleteTableRow(${r})" title="Delete row">âœ•</button></td>`;
                for (let c = 0; c < numCols; c++) {
                    const cellVal = (row && row[c]) || '';
                    html += `<td>
                        <input type="text" class="cell-input" value="${escapeHtml(cellVal)}" 
                            placeholder="Cell"
                            onchange="updateTableCell(${r}, ${c}, this.value)" />
                    </td>`;
                }
                html += '<td></td>';
                html += '</tr>';
            });
            html += '</tbody>';
            
            html += '</table>';
            container.innerHTML = html;
            
            // Update style controls
            const gridSelect = document.getElementById('table-grid-lines');
            if (gridSelect) {
                gridSelect.value = style.table_grid_lines || 'all';
            }
            const hideHeaderCheckbox = document.getElementById('table-hide-header');
            if (hideHeaderCheckbox) {
                hideHeaderCheckbox.checked = style.hide_header === true;
            }
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            return String(text).replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;')
                       .replace(/'/g, '&#039;');
        }
        
        function ensureTableStructure(q) {
            if (!q.data) q.data = { content: '', style: { image_layout: 'vertical', table_grid_lines: 'all', hide_header: false } };
            if (!q.data.table) q.data.table = { rows: [] };
            if (!q.data.table.rows) q.data.table.rows = [];
        }
        
        function addTableRow() {
            const q = activeData[activeIndex];
            ensureTableStructure(q);
            
            const numCols = q.data.table.header?.length || (q.data.table.rows[0]?.length || 2);
            const newRow = Array(numCols).fill('');
            q.data.table.rows.push(newRow);
            
            renderTableEditor(q.data);
            updateJsonView();
            refreshPreviewIfVisible();
        }
        
        function deleteTableRow(rowIdx) {
            const q = activeData[activeIndex];
            if (q.data?.table?.rows && q.data.table.rows.length > 1) {
                q.data.table.rows.splice(rowIdx, 1);
                renderTableEditor(q.data);
                updateJsonView();
                refreshPreviewIfVisible();
            } else {
                alert('Table must have at least one row.');
            }
        }
        
        function addTableColumn() {
            const q = activeData[activeIndex];
            ensureTableStructure(q);
            
            // Add header
            if (!q.data.table.header) q.data.table.header = [];
            q.data.table.header.push('');
            
            // Add cell to each row
            q.data.table.rows.forEach(row => {
                row.push('');
            });
            
            // v4.9: Recalculate column widths to distribute evenly
            const numCols = q.data.table.header.length;
            if (q.data.style?.column_widths && q.data.style.column_widths.length > 0) {
                // Redistribute existing widths proportionally
                const equalWidth = (100 / numCols).toFixed(1) + '%';
                q.data.style.column_widths = Array(numCols).fill(equalWidth);
            }
            
            renderTableEditor(q.data);
            updateJsonView();
            refreshPreviewIfVisible();
        }
        
        function deleteTableColumn() {
            const q = activeData[activeIndex];
            const numCols = q.data?.table?.header?.length || (q.data?.table?.rows[0]?.length || 0);
            
            if (numCols > 1) {
                // Remove from header
                if (q.data.table.header && q.data.table.header.length > 0) {
                    q.data.table.header.pop();
                }
                // Remove from each row
                q.data.table.rows.forEach(row => {
                    if (row.length > 0) row.pop();
                });
                // v4.9: Recalculate column widths after removing a column
                if (q.data.style?.column_widths && q.data.style.column_widths.length > 0) {
                    q.data.style.column_widths.pop();
                    // Redistribute remaining widths to total 100%
                    const remaining = q.data.style.column_widths;
                    if (remaining.length > 0) {
                        // Parse existing percentages and recalculate
                        let total = 0;
                        const values = remaining.map(w => {
                            const val = parseFloat(w) || (100 / remaining.length);
                            total += val;
                            return val;
                        });
                        // Normalize to 100%
                        q.data.style.column_widths = values.map(v => ((v / total) * 100).toFixed(1) + '%');
                    }
                }
                
                renderTableEditor(q.data);
                updateJsonView();
                refreshPreviewIfVisible();
            } else {
                alert('Table must have at least one column.');
            }
        }
        
        // v4.9: Column resize functionality (percentage-based)
        let isColResizing = false;
        let colResizeStartX = 0;
        let colResizeColIndex = -1;
        let colResizeStartWidths = []; // All column widths at start
        let colResizeTableWidth = 0;
        let colResizeTable = null;
        let colResizeHeader = null;
        let colResizeNumCols = 0;
        
        function initColResize(e, colIndex) {
            e.preventDefault();
            e.stopPropagation();
            
            if (activeIndex < 0 || !activeData[activeIndex]) return;
            
            const table = document.getElementById('table-editor-table');
            if (!table) return;
            
            isColResizing = true;
            colResizeStartX = e.clientX;
            colResizeColIndex = colIndex;
            colResizeTable = table;
            
            // Get the header cells and their current widths
            const headerCells = table.querySelectorAll('thead th.resizable');
            colResizeNumCols = headerCells.length;
            colResizeHeader = headerCells[colIndex];
            
            // Calculate total width of data columns (excluding corner and action columns)
            colResizeTableWidth = 0;
            colResizeStartWidths = [];
            headerCells.forEach((th, i) => {
                const width = th.offsetWidth;
                colResizeStartWidths.push(width);
                colResizeTableWidth += width;
            });
            
            if (colResizeHeader) {
                colResizeHeader.classList.add('resizing');
            }
            
            document.addEventListener('mousemove', handleColResize);
            document.addEventListener('mouseup', stopColResize);
        }
        
        function handleColResize(e) {
            if (!isColResizing || !colResizeHeader || colResizeNumCols < 2) return;
            
            const deltaX = e.clientX - colResizeStartX;
            const minWidthPx = 40; // Minimum column width in pixels
            
            // Calculate new width for the resized column
            const currentColStartWidth = colResizeStartWidths[colResizeColIndex];
            const nextColStartWidth = colResizeStartWidths[colResizeColIndex + 1];
            
            // The resized column takes from the next column
            let newCurrentWidth = Math.max(minWidthPx, currentColStartWidth + deltaX);
            let newNextWidth = Math.max(minWidthPx, nextColStartWidth - deltaX);
            
            // Ensure we don't exceed bounds
            if (newCurrentWidth < minWidthPx) {
                newCurrentWidth = minWidthPx;
                newNextWidth = currentColStartWidth + nextColStartWidth - minWidthPx;
            }
            if (newNextWidth < minWidthPx) {
                newNextWidth = minWidthPx;
                newCurrentWidth = currentColStartWidth + nextColStartWidth - minWidthPx;
            }
            
            // Convert to percentages
            const currentPct = (newCurrentWidth / colResizeTableWidth * 100).toFixed(1);
            const nextPct = (newNextWidth / colResizeTableWidth * 100).toFixed(1);
            
            // Update the col elements
            const cols = colResizeTable.querySelectorAll('colgroup col');
            const currentColEl = cols[colResizeColIndex + 1]; // +1 because first col is for row actions
            const nextColEl = cols[colResizeColIndex + 2];
            
            if (currentColEl) {
                currentColEl.style.width = currentPct + '%';
            }
            if (nextColEl) {
                nextColEl.style.width = nextPct + '%';
            }
            
            // Update indicator
            const indicator = colResizeHeader.querySelector('.col-width-indicator');
            if (indicator) {
                indicator.textContent = currentPct + '%';
            }
        }
        
        function stopColResize() {
            if (isColResizing && colResizeTable && colResizeColIndex >= 0) {
                // Calculate final percentages for ALL columns
                const headerCells = colResizeTable.querySelectorAll('thead th.resizable');
                const finalWidths = [];
                let totalWidth = 0;
                
                headerCells.forEach(th => {
                    const width = th.offsetWidth;
                    finalWidths.push(width);
                    totalWidth += width;
                });
                
                // Convert all widths to percentages
                const percentages = finalWidths.map(w => {
                    const pct = (w / totalWidth * 100).toFixed(1);
                    return pct + '%';
                });
                
                // Save to question data
                updateAllColumnWidths(percentages);
                
                if (colResizeHeader) {
                    colResizeHeader.classList.remove('resizing');
                }
            }
            
            isColResizing = false;
            colResizeStartX = 0;
            colResizeColIndex = -1;
            colResizeStartWidths = [];
            colResizeTableWidth = 0;
            colResizeTable = null;
            colResizeHeader = null;
            colResizeNumCols = 0;
            
            document.removeEventListener('mousemove', handleColResize);
            document.removeEventListener('mouseup', stopColResize);
        }
        
        function updateAllColumnWidths(percentages) {
            if (activeIndex < 0 || !activeData[activeIndex]) return;
            
            const q = activeData[activeIndex];
            if (!q.data) q.data = {};
            if (!q.data.style) q.data.style = {};
            
            // Set all column widths
            q.data.style.column_widths = percentages;
            
            updateJsonView();
            renderList();
            refreshPreviewIfVisible();
        }
        
        function clearColumnWidths() {
            if (activeIndex < 0 || !activeData[activeIndex]) return;
            
            const q = activeData[activeIndex];
            if (q.data?.style?.column_widths) {
                delete q.data.style.column_widths;
                renderTableEditor(q.data);
                updateJsonView();
                refreshPreviewIfVisible();
            }
        }
        
        function updateTableHeader(colIdx, value) {
            const q = activeData[activeIndex];
            ensureTableStructure(q);
            
            if (!q.data.table.header) {
                // Initialize header array if needed
                const numCols = q.data.table.rows[0]?.length || 2;
                q.data.table.header = Array(numCols).fill('');
            }
            
            // Expand header if needed
            while (q.data.table.header.length <= colIdx) {
                q.data.table.header.push('');
            }
            
            q.data.table.header[colIdx] = value;
            updateJsonView();
            refreshPreviewIfVisible();
        }
        
        function updateTableCell(rowIdx, colIdx, value) {
            const q = activeData[activeIndex];
            ensureTableStructure(q);
            
            // Ensure row exists
            while (q.data.table.rows.length <= rowIdx) {
                const numCols = q.data.table.header?.length || 2;
                q.data.table.rows.push(Array(numCols).fill(''));
            }
            
            // Ensure column exists in row
            while (q.data.table.rows[rowIdx].length <= colIdx) {
                q.data.table.rows[rowIdx].push('');
            }
            
            q.data.table.rows[rowIdx][colIdx] = value;
            updateJsonView();
            refreshPreviewIfVisible();
        }
        
        function updateTableGridLines(value) {
            const q = activeData[activeIndex];
            if (!q.data) q.data = {};
            if (!q.data.style) q.data.style = {};
            q.data.style.table_grid_lines = value;
            updateJsonView();
            refreshPreviewIfVisible();
        }
        
        function updateTableHideHeader(checked) {
            const q = activeData[activeIndex];
            if (!q.data) q.data = {};
            if (!q.data.style) q.data.style = {};
            q.data.style.hide_header = checked;
            updateJsonView();
            refreshPreviewIfVisible();
        }
        
        function refreshPreviewIfVisible() {
            const previewContainer = document.getElementById('view-preview');
            if (previewContainer.classList.contains('active')) {
                const q = activeData[activeIndex];
                renderPreview(q, activeIndex);
            }
        }

        // =====================================================
        // GRADING MANAGEMENT
        // =====================================================
        
        const COMPLEX_GRADING_KINDS = ['matching', 'sequencing', 'grouping', 'coordinate'];
        
        function updateGrading(field, value) {
            const q = activeData[activeIndex];
            if(!q.grading) q.grading = { kind: 'text', values: [], points: '1' };
            q.grading[field] = value;
            
            // Also update the points in the header if points field changed
            if (field === 'points') {
                document.getElementById('meta-points').value = value;
            }
            
            updateJsonView();
        }

        function onGradingKindChange(kind) {
            const q = activeData[activeIndex];
            updateGrading('kind', kind);
            
            // Toggle between simple and complex value editors
            const simpleEditor = document.getElementById('grading-values-simple');
            const complexEditor = document.getElementById('grading-values-complex');
            const isComplex = COMPLEX_GRADING_KINDS.includes(kind);
            
            simpleEditor.style.display = isComplex ? 'none' : 'block';
            complexEditor.style.display = isComplex ? 'block' : 'none';
            
            // Update label for simple editors
            const label = document.getElementById('grading-values-label');
            if (kind === 'single_selection') {
                label.textContent = 'Correct Option ID (e.g., "a" or "b")';
            } else if (kind === 'multiple_selection') {
                label.textContent = 'Correct Option IDs (comma-separated, e.g., "a, c")';
            } else {
                label.textContent = 'Values (comma-separated for multiple answers)';
            }
            
            // Render complex editor if needed
            if (isComplex) {
                renderComplexGradingEditor(kind);
            }
        }

        function renderComplexGradingEditor(kind) {
            const q = activeData[activeIndex];
            const container = document.getElementById('grading-values-editor');
            const values = q.grading?.values || [];
            
            let html = '';
            
            if (kind === 'matching') {
                html = `
                    <div class="grading-field">
                        <label style="color:#7c3aed;">Matching Pairs (left_id â†’ right_id)</label>
                        <div id="matching-pairs-list"></div>
                        <button class="btn btn-sm" onclick="addMatchingPair()" style="margin-top:0.5rem; background:#f5f3ff; border-color:#c4b5fd;">+ Add Pair</button>
                    </div>`;
                container.innerHTML = html;
                renderMatchingPairs(values);
            } else if (kind === 'sequencing') {
                html = `
                    <div class="grading-field">
                        <label style="color:#0284c7;">Correct Order (comma-separated item IDs)</label>
                        <input type="text" class="input-bare" id="sequencing-order" 
                               value="${values.length > 0 && values[0]?.order ? values[0].order.join(', ') : ''}"
                               oninput="updateSequencingOrder(this.value)"
                               placeholder="e.g., item3, item1, item2" style="color:#0284c7;">
                    </div>`;
                container.innerHTML = html;
            } else if (kind === 'grouping') {
                html = `
                    <div class="grading-field">
                        <label style="color:#b45309;">Group Assignments (group_id: item1, item2...)</label>
                        <div id="grouping-list"></div>
                        <button class="btn btn-sm" onclick="addGroupingEntry()" style="margin-top:0.5rem; background:#fef3c7; border-color:#fcd34d;">+ Add Group Entry</button>
                    </div>`;
                container.innerHTML = html;
                renderGroupingEntries(values);
            } else if (kind === 'coordinate') {
                html = `
                    <div class="grading-field">
                        <label style="color:#dc2626;">Coordinate Labels (label_id: x, y)</label>
                        <div id="coordinate-list"></div>
                        <button class="btn btn-sm" onclick="addCoordinateEntry()" style="margin-top:0.5rem; background:#fee2e2; border-color:#fecaca;">+ Add Label</button>
                    </div>`;
                container.innerHTML = html;
                renderCoordinateEntries(values);
            }
        }
        
        // --- Matching Pairs Editor ---
        function renderMatchingPairs(values) {
            const container = document.getElementById('matching-pairs-list');
            if (!container) return;
            container.innerHTML = '';
            
            const pairs = values.filter(v => v && v.pair);
            pairs.forEach((item, idx) => {
                const el = document.createElement('div');
                el.style.cssText = 'display:flex; gap:0.5rem; align-items:center; margin-bottom:0.5rem; padding:0.5rem; background:#f5f3ff; border-radius:4px; border:1px solid #c4b5fd;';
                el.innerHTML = `
                    <input type="text" value="${item.pair[0] || ''}" placeholder="Left ID" 
                           oninput="updateMatchingPair(${idx}, 0, this.value)"
                           style="width:80px; padding:0.4rem; border:1px solid #c4b5fd; border-radius:4px;">
                    <span style="color:#7c3aed;">â†’</span>
                    <input type="text" value="${item.pair[1] || ''}" placeholder="Right ID" 
                           oninput="updateMatchingPair(${idx}, 1, this.value)"
                           style="width:80px; padding:0.4rem; border:1px solid #c4b5fd; border-radius:4px;">
                    <button class="btn btn-sm delete-sub-btn" onclick="deleteMatchingPair(${idx})">âœ•</button>
                `;
                container.appendChild(el);
            });
            
            if (pairs.length === 0) {
                container.innerHTML = '<div style="padding:0.5rem; color:#999; font-size:0.85rem;">No pairs yet. Click "+ Add Pair".</div>';
            }
        }
        
        function addMatchingPair() {
            const q = activeData[activeIndex];
            if (!q.grading) q.grading = { kind: 'matching', values: [], points: '1' };
            q.grading.values.push({ pair: ['', ''] });
            renderMatchingPairs(q.grading.values);
            updateJsonView();
        }
        
        function updateMatchingPair(idx, pairIdx, value) {
            const q = activeData[activeIndex];
            if (q.grading?.values?.[idx]?.pair) {
                q.grading.values[idx].pair[pairIdx] = value;
            }
            updateJsonView();
        }
        
        function deleteMatchingPair(idx) {
            const q = activeData[activeIndex];
            if (q.grading?.values) {
                q.grading.values.splice(idx, 1);
                renderMatchingPairs(q.grading.values);
            }
            updateJsonView();
        }
        
        // --- Sequencing Order Editor ---
        function updateSequencingOrder(value) {
            const q = activeData[activeIndex];
            if (!q.grading) q.grading = { kind: 'sequencing', values: [], points: '1' };
            const orderItems = value.split(',').map(v => v.trim()).filter(v => v);
            q.grading.values = [{ order: orderItems }];
            updateJsonView();
        }
        
        // --- Grouping Editor ---
        function renderGroupingEntries(values) {
            const container = document.getElementById('grouping-list');
            if (!container) return;
            container.innerHTML = '';
            
            const entries = values.filter(v => v && v.group);
            entries.forEach((item, idx) => {
                const el = document.createElement('div');
                el.style.cssText = 'display:flex; gap:0.5rem; align-items:center; margin-bottom:0.5rem; padding:0.5rem; background:#fef3c7; border-radius:4px; border:1px solid #fcd34d;';
                el.innerHTML = `
                    <input type="text" value="${item.group || ''}" placeholder="Group ID" 
                           oninput="updateGroupingEntry(${idx}, 'group', this.value)"
                           style="width:60px; padding:0.4rem; border:1px solid #fcd34d; border-radius:4px; font-weight:600;">
                    <span style="color:#b45309;">:</span>
                    <input type="text" value="${(item.items || []).join(', ')}" placeholder="Item IDs (comma-separated)" 
                           oninput="updateGroupingEntry(${idx}, 'items', this.value)"
                           style="flex:1; padding:0.4rem; border:1px solid #fcd34d; border-radius:4px;">
                    <button class="btn btn-sm delete-sub-btn" onclick="deleteGroupingEntry(${idx})">âœ•</button>
                `;
                container.appendChild(el);
            });
            
            if (entries.length === 0) {
                container.innerHTML = '<div style="padding:0.5rem; color:#999; font-size:0.85rem;">No groups yet. Click "+ Add Group Entry".</div>';
            }
        }
        
        function addGroupingEntry() {
            const q = activeData[activeIndex];
            if (!q.grading) q.grading = { kind: 'grouping', values: [], points: '1' };
            q.grading.values.push({ group: '', items: [] });
            renderGroupingEntries(q.grading.values);
            updateJsonView();
        }
        
        function updateGroupingEntry(idx, field, value) {
            const q = activeData[activeIndex];
            if (!q.grading?.values?.[idx]) return;
            if (field === 'group') {
                q.grading.values[idx].group = value;
            } else if (field === 'items') {
                q.grading.values[idx].items = value.split(',').map(v => v.trim()).filter(v => v);
            }
            updateJsonView();
        }
        
        function deleteGroupingEntry(idx) {
            const q = activeData[activeIndex];
            if (q.grading?.values) {
                q.grading.values.splice(idx, 1);
                renderGroupingEntries(q.grading.values);
            }
            updateJsonView();
        }
        
        // --- Coordinate Editor ---
        function renderCoordinateEntries(values) {
            const container = document.getElementById('coordinate-list');
            if (!container) return;
            container.innerHTML = '';
            
            const entries = values.filter(v => v && v.label_id);
            entries.forEach((item, idx) => {
                const el = document.createElement('div');
                el.style.cssText = 'display:flex; gap:0.5rem; align-items:center; margin-bottom:0.5rem; padding:0.5rem; background:#fee2e2; border-radius:4px; border:1px solid #fecaca;';
                el.innerHTML = `
                    <input type="text" value="${item.label_id || ''}" placeholder="Label" 
                           oninput="updateCoordinateEntry(${idx}, 'label_id', this.value)"
                           style="width:80px; padding:0.4rem; border:1px solid #fecaca; border-radius:4px; font-weight:600;">
                    <span style="color:#dc2626;">x:</span>
                    <input type="number" value="${item.x || ''}" placeholder="X" 
                           oninput="updateCoordinateEntry(${idx}, 'x', parseFloat(this.value))"
                           style="width:60px; padding:0.4rem; border:1px solid #fecaca; border-radius:4px;">
                    <span style="color:#dc2626;">y:</span>
                    <input type="number" value="${item.y || ''}" placeholder="Y" 
                           oninput="updateCoordinateEntry(${idx}, 'y', parseFloat(this.value))"
                           style="width:60px; padding:0.4rem; border:1px solid #fecaca; border-radius:4px;">
                    <button class="btn btn-sm delete-sub-btn" onclick="deleteCoordinateEntry(${idx})">âœ•</button>
                `;
                container.appendChild(el);
            });
            
            if (entries.length === 0) {
                container.innerHTML = '<div style="padding:0.5rem; color:#999; font-size:0.85rem;">No labels yet. Click "+ Add Label".</div>';
            }
        }
        
        function addCoordinateEntry() {
            const q = activeData[activeIndex];
            if (!q.grading) q.grading = { kind: 'coordinate', values: [], points: '1' };
            q.grading.values.push({ label_id: '', x: 0, y: 0 });
            renderCoordinateEntries(q.grading.values);
            updateJsonView();
        }
        
        function updateCoordinateEntry(idx, field, value) {
            const q = activeData[activeIndex];
            if (!q.grading?.values?.[idx]) return;
            q.grading.values[idx][field] = value;
            updateJsonView();
        }
        
        function deleteCoordinateEntry(idx) {
            const q = activeData[activeIndex];
            if (q.grading?.values) {
                q.grading.values.splice(idx, 1);
                renderCoordinateEntries(q.grading.values);
            }
            updateJsonView();
        }

        function updateGradingValues(value) {
            const q = activeData[activeIndex];
            if(!q.grading) q.grading = { kind: 'text', values: [], points: '1' };
            // Parse comma-separated values for multi-value answers (simple types only)
            q.grading.values = value.split(',').map(v => v.trim()).filter(v => v);
            updateJsonView();
        }

        // =====================================================
        // METADATA MANAGEMENT
        // =====================================================
        
        function updateMetadata(field, value) {
            const q = activeData[activeIndex];
            if(!q.metadata) q.metadata = { ui_hint: 'rich_text_editor', version: 2, source: 'AI_Generated' };
            q.metadata[field] = value;
            updateJsonView();
        }


        // =====================================================
        // SUB-QUESTION MANAGEMENT (v4.0 schema)
        // =====================================================
        
        function addSubQuestion() {
            const q = activeData[activeIndex];
            if (!q.data) q.data = {};
            if(!q.data.sub_questions) q.data.sub_questions = [];
            const newIdx = q.data.sub_questions.length;
            const newSubId = `Q${q.id || activeIndex + 1}-${String.fromCharCode(97 + newIdx)}`; // Q1-a, Q1-b, etc.
            q.data.sub_questions.push({
                id: newSubId,
                type: 'SUBJECTIVE',
                data: { content: '' }
            });
            renderSubQuestions(q);
            updateJsonView();
        }

        function deleteSubQuestion(idx) {
            const q = activeData[activeIndex];
            if (!q.data?.sub_questions) return;
            q.data.sub_questions.splice(idx, 1);
            // Re-index sub ids
            q.data.sub_questions.forEach((sq, i) => {
                sq.id = `Q${q.id || activeIndex + 1}-${String.fromCharCode(97 + i)}`;
            });
            renderSubQuestions(q);
            recalculateTotalMarks();
            updateJsonView();
        }

        function updateSubQuestionType(idx, type) {
            const q = activeData[activeIndex];
            if (!q.data?.sub_questions?.[idx]) return;
            q.data.sub_questions[idx].type = type;
            // Add/remove options based on type
            if(type === 'MCQ') {
                if(!q.data.sub_questions[idx].data) q.data.sub_questions[idx].data = {};
                if(!q.data.sub_questions[idx].data.options) {
                    q.data.sub_questions[idx].data.options = [
                        { id: 'a', text: 'Option A' },
                        { id: 'b', text: 'Option B' }
                    ];
                }
            }
            renderSubQuestions(q);
            updateJsonView();
        }

        function addSubQuestionOption(sqIdx) {
            const q = activeData[activeIndex];
            const sq = q.data?.sub_questions?.[sqIdx];
            if(!sq) return;
            if(!sq.data) sq.data = {};
            if(!sq.data.options) sq.data.options = [];
            const newIdx = sq.data.options.length;
            sq.data.options.push({ id: String.fromCharCode(97 + newIdx), text: '' });
            renderSubQuestions(q);
            updateJsonView();
        }

        function deleteSubQuestionOption(sqIdx, optIdx) {
            const q = activeData[activeIndex];
            if (q.data?.sub_questions?.[sqIdx]?.data?.options) {
                q.data.sub_questions[sqIdx].data.options.splice(optIdx, 1);
            }
            renderSubQuestions(q);
            updateJsonView();
        }

        function setOptionsLayout(sqIdx, mode) {
            const q = activeData[activeIndex];
            const sq = q.data?.sub_questions?.[sqIdx];
            if (!sq) return;
            if (!sq.data) sq.data = {};
            if (!sq.data.style) sq.data.style = {};
            sq.data.style.options_layout = mode;
            renderSubQuestions(q);
            updateJsonView();
        }

        // =====================================================
        // SUB-QUESTION STIMULUS MANAGEMENT (v4.0 - not used)
        // =====================================================
        
        function addSubQuestionStimulus(sqIdx) {
            // v4.0 doesn't have separate stimulus - content is inline
            const q = activeData[activeIndex];
            const sq = q.data?.sub_questions?.[sqIdx];
            if (!sq) return;
            // No-op for v4.0
            renderSubQuestions(q);
            updateJsonView();
        }
        
        function removeSubQuestionStimulus(sqIdx) {
            const q = activeData[activeIndex];
            const sq = q.data?.sub_questions?.[sqIdx];
            if (!sq) return;
            
            if (confirm('Are you sure you want to remove this stimulus?')) {
                // No-op for v4.0
                renderSubQuestions(q);
                updateJsonView();
            }
        }
        
        function addSubQuestionStimulusAsset(sqIdx) {
            const q = activeData[activeIndex];
            const sq = q.content?.subquestions?.[sqIdx];
            if (!sq || !sq.stimulus) return;
            
            if (!sq.stimulus.assets) sq.stimulus.assets = [];
            sq.stimulus.assets.push({ asset_id: '#', ai_generation_prompt: 'Describe...', uri: '', alt: '' });
            renderSubQuestions(q);
            updateJsonView();
        }
        
        // --- PARSING HELPERS ---
        // NOTE: Core parsing functions (parseMixedJson, normalizeToNewSchema, etc.) 
        // are now in question-parser.js for shared use across tools

        function updateLayoutButtons(mode) {
            const currentMode = mode || 'vertical';  // Default to vertical for subquestions
            
            // Update toolbar buttons
            const btnVertical = document.getElementById('btn-layout-vertical');
            const btnHorizontal = document.getElementById('btn-layout-horizontal');
            if (btnVertical && btnHorizontal) {
                btnVertical.classList.toggle('active', currentMode === 'vertical');
                btnHorizontal.classList.toggle('active', currentMode === 'horizontal');
            }
            
            // Update subquestions section toggle
            const toggleContainer = document.getElementById('subquestions-layout-toggle');
            if (toggleContainer) {
                toggleContainer.querySelectorAll('.section-layout-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.layout === currentMode);
                });
            }
        }
        
        function renderSubQuestions(q) {
            const container = document.getElementById('sub-questions-list');
            container.innerHTML = '';
            // Use data.style.sub_questions_layout, default to vertical
            const mode = q.data?.style?.sub_questions_layout || 'vertical';
            container.className = `sub-questions-wrapper ${mode === 'horizontal' ? 'layout-horizontal' : ''}`;
            
            const subquestions = q.data?.sub_questions;
            if(subquestions && subquestions.length > 0) {
                subquestions.forEach((sq, sqIdx) => {
                    const card = document.createElement('div');
                    card.className = 'sub-question-card';
                    
                    // Header with controls
                    const headerRow = document.createElement('div');
                    headerRow.className = 'sub-question-header-row';
                    
                    const leftControls = document.createElement('div');
                    leftControls.style.display = 'flex';
                    leftControls.style.alignItems = 'center';
                    leftControls.style.gap = '8px';
                    
                    const badge = document.createElement('div');
                    badge.className = 'sub-id-badge';
                    badge.innerText = sq.id ? getIdDisplayLabel(sq.id) : String.fromCharCode(97 + sqIdx);
                    
                    // Type selector - v4.0 types
                    const typeSelect = document.createElement('select');
                    typeSelect.className = 'sub-question-type-select';
                    typeSelect.innerHTML = `
                        <option value="MCQ" ${sq.type === 'MCQ' ? 'selected' : ''}>MCQ</option>
                        <option value="FIB" ${sq.type === 'FIB' ? 'selected' : ''}>Fill Blank</option>
                        <option value="MATCH" ${sq.type === 'MATCH' ? 'selected' : ''}>Match</option>
                        <option value="SUBJECTIVE" ${sq.type === 'SUBJECTIVE' ? 'selected' : ''}>Subjective</option>
                        <option value="TABLE" ${sq.type === 'TABLE' ? 'selected' : ''}>Table</option>
                    `;
                    typeSelect.onchange = (e) => updateSubQuestionType(sqIdx, e.target.value);
                    
                    leftControls.appendChild(badge);
                    leftControls.appendChild(typeSelect);
                    
                    const rightControls = document.createElement('div');
                    rightControls.style.display = 'flex';
                    rightControls.style.alignItems = 'center';
                    rightControls.style.gap = '8px';
                    
                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-sub-btn';
                    deleteBtn.innerText = 'âœ•';
                    deleteBtn.onclick = () => deleteSubQuestion(sqIdx);
                    
                    rightControls.appendChild(deleteBtn);
                    
                    headerRow.appendChild(leftControls);
                    headerRow.appendChild(rightControls);
                    card.appendChild(headerRow);
                    
                    // Stimulus section for sub-question (if exists)
                    if (sq.stimulus) {
                        const stimSection = document.createElement('div');
                        stimSection.className = 'sq-stimulus-section';
                        stimSection.style.cssText = 'background:#f0f9ff; border:1px dashed #93c5fd; border-radius:6px; padding:0.75rem; margin-bottom:0.75rem;';
                        
                        const stimHeader = document.createElement('div');
                        stimHeader.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;';
                        stimHeader.innerHTML = `
                            <label style="font-size:0.7rem; font-weight:700; color:#1d4ed8; text-transform:uppercase;">ðŸ“„ Sub-Question Stimulus</label>
                            <div style="display:flex; gap:0.25rem;">
                                <button class="btn btn-sm" style="font-size:0.65rem;" onclick="addSubQuestionStimulusAsset(${sqIdx})">+ Image</button>
                                <button class="btn btn-sm" style="font-size:0.65rem; background:#fee2e2; color:#991b1b; border-color:#fecaca;" onclick="removeSubQuestionStimulus(${sqIdx})">âœ•</button>
                            </div>
                        `;
                        stimSection.appendChild(stimHeader);
                        
                        const stimInput = document.createElement('textarea');
                        stimInput.className = 'input-bare';
                        stimInput.style.cssText = 'font-size:0.9rem; min-height:60px; background:white;';
                        stimInput.value = sq.stimulus.text || '';
                        stimInput.placeholder = 'Enter stimulus text for this sub-question...';
                        stimInput.oninput = (e) => {
                            sq.stimulus.text = e.target.value;
                            updateJsonView();
                        };
                        stimSection.appendChild(stimInput);
                        
                        // Stimulus assets
                        if (sq.stimulus.assets && sq.stimulus.assets.length > 0) {
                            const stimAssetCont = document.createElement('div');
                            stimAssetCont.className = 'asset-container';
                            stimAssetCont.style.marginTop = '0.5rem';
                            renderAssetList(sq.stimulus.assets, stimAssetCont, (newAssets) => {
                                sq.stimulus.assets = newAssets;
                                updateJsonView();
                            });
                            stimSection.appendChild(stimAssetCont);
                        }
                        
                        card.appendChild(stimSection);
                    }
                    
                    // Content wrapper (stack layout only - layout control removed from individual sub-questions)
                    const contentWrapper = document.createElement('div');
                    contentWrapper.className = 'sq-content-stack';
                    
                    // Text area container
                    const textArea = document.createElement('div');
                    textArea.className = 'sq-text-area';
                    
                    // Content text input - v4.0 uses sq.data.content
                    const input = document.createElement('textarea');
                    input.className = 'input-bare sub-input';
                    const sqData = sq.data || {};
                    const sqText = sqData.content || '';
                    input.value = sqText;
                    input.placeholder = 'Enter text...';
                    input.oninput = (e) => { 
                        if (!sq.data) sq.data = {};
                        sq.data.content = e.target.value;
                        updateJsonView(); 
                    };
                    textArea.appendChild(input);
                    contentWrapper.appendChild(textArea);
                    
                    // Asset container - v4.0 uses [[image:tag]] tokens, not assets array
                    const assetCont = document.createElement('div');
                    assetCont.className = 'asset-container';
                    assetCont.innerHTML = '<span style="font-size:0.7rem; color:#999;">Images: [[image:tag]] | Blanks: [[gap]] | Math: $x^2$ or $$x^2$$ | **bold** *italic*</span>';
                    contentWrapper.appendChild(assetCont);
                    
                    card.appendChild(contentWrapper);
                    
                    // Options for MCQ type - v4.0 uses sq.data.options
                    const sqOptions = sqData.options || [];
                    if (sq.type === 'MCQ' && sqOptions.length > 0) {
                        const optDiv = document.createElement('div');
                        optDiv.className = 'options-editor';
                        const currentOptLayout = sqData.style?.options_layout || 'horizontal';
                        optDiv.innerHTML = `
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                                <label style="font-size:0.7rem; font-weight:700; color:#6b7280; text-transform:uppercase;">Options</label>
                                <div style="display:flex; gap:0.5rem; align-items:center;">
                                    <div class="section-layout-toggle" style="padding:1px;">
                                        <button class="section-layout-btn ${currentOptLayout === 'vertical' ? 'active' : ''}" onclick="setOptionsLayout(${sqIdx}, 'vertical')" title="Stack vertically">â˜°</button>
                                        <button class="section-layout-btn ${currentOptLayout === 'horizontal' ? 'active' : ''}" onclick="setOptionsLayout(${sqIdx}, 'horizontal')" title="Arrange horizontally">âŠž</button>
                                    </div>
                                <button class="btn btn-sm" style="font-size:0.65rem;" onclick="addSubQuestionOption(${sqIdx})">+ Add</button>
                                </div>
                            </div>
                        `;
                        sqOptions.forEach((opt, oIdx) => {
                            const optRow = document.createElement('div');
                            optRow.className = 'option-row';
                            const radio = document.createElement('div');
                            radio.className = 'option-radio';
                            if(sqData.allow_multiple) radio.style.borderRadius = '2px'; // Checkbox style
                            const optInput = document.createElement('input');
                            optInput.className = 'option-input';
                            const optVal = opt.text || '';
                            optInput.value = optVal;
                            optInput.placeholder = 'Enter text...';
                            optInput.oninput = (e) => {
                                if (!sq.data) sq.data = { options: [] };
                                if (!sq.data.options[oIdx]) sq.data.options[oIdx] = { id: String.fromCharCode(97 + oIdx), text: '' };
                                sq.data.options[oIdx].text = e.target.value;
                                updateJsonView(); 
                            };
                            const delOptBtn = document.createElement('button');
                            delOptBtn.className = 'btn btn-sm';
                            delOptBtn.style.padding = '2px 6px';
                            delOptBtn.style.fontSize = '0.65rem';
                            delOptBtn.style.color = '#991b1b';
                            delOptBtn.innerText = 'âœ•';
                            delOptBtn.onclick = () => deleteSubQuestionOption(sqIdx, oIdx);
                            
                            optRow.appendChild(radio);
                            optRow.appendChild(optInput);
                            optRow.appendChild(delOptBtn);
                            optDiv.appendChild(optRow);
                        });
                        card.appendChild(optDiv);
                    }
                    
                    // Action buttons row
                    const actionsRow = document.createElement('div');
                    actionsRow.style.display = 'flex';
                    actionsRow.style.gap = '0.5rem';
                    actionsRow.style.marginTop = '0.5rem';
                    
                    // Add options button for MCQ types without options yet
                    if (sq.type === 'MCQ' && sqOptions.length === 0) {
                        const addOptBtn = document.createElement('button');
                        addOptBtn.className = 'btn btn-sm';
                        addOptBtn.innerText = '+ Options';
                        addOptBtn.onclick = () => {
                            if (!sq.data) sq.data = {};
                            sq.data.options = [
                                { id: 'a', text: '' },
                                { id: 'b', text: '' }
                            ];
                            renderSubQuestions(q);
                            updateJsonView();
                        };
                        actionsRow.appendChild(addOptBtn);
                    }
                    
                    card.appendChild(actionsRow);
                    
                    container.appendChild(card);
                });
            }
        }

        function renderAssetList(assetsArray, containerOrId, updateCallback) {
            const container = typeof containerOrId === 'string' ? document.getElementById(containerOrId) : containerOrId;
            container.innerHTML = '';
            if(!assetsArray) return;
            assetsArray.forEach((asset, idx) => {
                const el = document.createElement('div');
                // Check for truthy uri value (not null, undefined, or empty string)
                const hasImage = asset.uri && asset.uri.length > 0;
                
                if (hasImage) {
                    // Compact view: just the image with hover controls
                    el.className = 'asset-item-compact';
                    
                    // Get stored dimensions or use defaults
                    const width = asset.width || 150;
                    const height = asset.height || 120;
                    const altText = asset.alt || 'Image';
                    
                    el.innerHTML = `
                        <div class="asset-image-container" style="width:${width}px; height:${height}px;">
                            <img src="${asset.uri}" alt="${altText}">
                            <div class="asset-hover-controls">
                                <button class="asset-hover-btn replace-btn" title="Replace Image">ðŸ”„</button>
                                <button class="asset-hover-btn delete-btn" title="Delete">âœ•</button>
                            </div>
                        </div>
                    `;
                    
                    // Track resize and save dimensions
                    const imgContainer = el.querySelector('.asset-image-container');
                    const resizeObserver = new ResizeObserver((entries) => {
                        for (const entry of entries) {
                            const newWidth = Math.round(entry.contentRect.width);
                            const newHeight = Math.round(entry.contentRect.height);
                            if (newWidth > 0 && newHeight > 0) {
                                asset.width = newWidth;
                                asset.height = newHeight;
                                updateJsonView();
                            }
                        }
                    });
                    resizeObserver.observe(imgContainer);
                    
                    el.querySelector('.delete-btn').onclick = () => { 
                        resizeObserver.disconnect();
                        assetsArray.splice(idx, 1); 
                        updateCallback(assetsArray); 
                        renderAssetList(assetsArray, container, updateCallback); 
                        updateJsonView(); 
                    };
                    el.querySelector('.replace-btn').onclick = () => {
                        triggerImageUpload((dataUrl) => { 
                            asset.uri = dataUrl;
                            // Keep existing dimensions when replacing
                            updateCallback(assetsArray); 
                            renderAssetList(assetsArray, container, updateCallback); 
                            updateJsonView(); 
                        });
                    };
                } else {
                    // Full controls view: for pending images
                el.className = 'asset-item';
                el.innerHTML = `
                        <div class="asset-preview" style="border-color:var(--warning); border-width:2px; border-style:dashed;">
                            <span style="color:#94a3b8;">ðŸ–¼ï¸</span>
                        </div>
                    <div class="asset-details">
                        <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                                <span style="font-size:0.7rem; font-weight:700; color:var(--warning);">PENDING</span>
                            <button class="btn btn-sm btn-danger" style="padding:2px 6px; font-size:0.7rem;">Ã—</button>
                        </div>
                            <input class="asset-prompt-input" value="${asset.ai_generation_prompt || ''}" placeholder="AI Prompt description...">
                            <input class="asset-alt-input" value="${asset.alt || ''}" placeholder="Alt text (accessibility)..." style="margin-top:4px; width:100%; font-size:0.8rem; color:#4b5563; font-family:monospace; border:1px solid #e5e7eb; padding:4px; border-radius:4px;">
                        <div style="margin-top:4px; display:flex; gap:0.5rem;">
                                <button class="btn btn-sm gen-btn" style="background:var(--warning); color:white; border:none;">Generate</button>
                                <button class="btn btn-sm upload-btn" style="background:var(--primary); color:white; border:none;">Insert Image</button>
                        </div>
                    </div>
                `;
                    el.querySelector('.btn-danger').onclick = () => { 
                        assetsArray.splice(idx, 1); 
                        updateCallback(assetsArray); 
                        renderAssetList(assetsArray, container, updateCallback); 
                        updateJsonView(); 
                    };
                    el.querySelector('.asset-prompt-input').oninput = (e) => { asset.ai_generation_prompt = e.target.value; updateJsonView(); };
                    el.querySelector('.asset-alt-input').oninput = (e) => { asset.alt = e.target.value; updateJsonView(); };
                el.querySelector('.gen-btn').onclick = (e) => {
                    e.target.innerText = 'Generating...';
                    setTimeout(() => {
                            const safeText = encodeURIComponent((asset.ai_generation_prompt || 'image').substring(0, 20));
                            asset.uri = `https://placehold.co/400x300/e0f2fe/0284c7?text=${safeText}`;
                            asset.asset_id = '#'; // Will be calculated on server
                            updateCallback(assetsArray);
                            renderAssetList(assetsArray, container, updateCallback);
                        updateJsonView(); 
                    }, 1500);
                };
                el.querySelector('.upload-btn').onclick = () => {
                        triggerImageUpload((dataUrl) => { 
                            asset.uri = dataUrl;
                            asset.asset_id = '#'; // Will be calculated on server
                            updateCallback(assetsArray); 
                            renderAssetList(assetsArray, container, updateCallback); 
                            updateJsonView(); 
                        });
                    };
                }
                container.appendChild(el);
            });
        }
        
        // Store the current upload callback globally to handle file selection
        let currentImageUploadCallback = null;
        
        function triggerImageUpload(callback) {
            const input = document.getElementById('image-upload-input');
            
            // Store the callback
            currentImageUploadCallback = callback;
            
            // Reset the input value so the same file can be selected again
            input.value = '';
            
            // Trigger the file input click
            input.click();
        }
        
        // Set up a single event listener for the image upload input
        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('image-upload-input');
            if (input) {
                input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                    if (!file) return;
                    
                    if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                            if (currentImageUploadCallback) {
                                currentImageUploadCallback(event.target.result);
                                currentImageUploadCallback = null; // Clear after use
                            }
                    };
                    reader.onerror = () => {
                        alert('Error reading image file');
                            currentImageUploadCallback = null;
                    };
                    reader.readAsDataURL(file);
                    } else {
                        alert('Please select an image file (JPEG, PNG, GIF, etc.)');
                    }
                    
                    // Reset the input
                    e.target.value = '';
                });
            }
        });
        
        function downloadJSONL() {
            // Prepare data for export using shared prepareForExport function
            const exportData = activeData.map(q => prepareForExport(q));
            
            let jsonl = exportData.map(q => JSON.stringify(q)).join('\n');
            const blob = new Blob([jsonl], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = activeWorkflow === 'import' ? 'published_questions.jsonl' : 'library_export.jsonl';
            a.click();
            
            // Update workflow animation - Step 3 completed
            updateWorkflowState(3);
        }

        function switchTab(tab) {
            const poolSelect = document.getElementById('meta-pool-type');
            const diffSelect = document.getElementById('meta-difficulty');
            const pointInput = document.getElementById('meta-points');
            
            // Update tab button classes first
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');
            
            // Update view containers
            document.querySelectorAll('.edit-view-container, .preview-view-container').forEach(v => v.classList.remove('active'));
            
            if (tab === 'preview') {
                poolSelect.disabled = true;
                diffSelect.disabled = true;
                pointInput.disabled = true;
                document.getElementById('view-preview').classList.add('active');
                renderPreview(activeData[activeIndex], activeIndex);
            } else {
                poolSelect.disabled = false;
                diffSelect.disabled = false;
                pointInput.disabled = false;
                document.getElementById('view-edit').classList.add('active');
                // Re-populate the editor to ensure it's up to date
                populateEditor(activeData[activeIndex]);
            }
        }

        function switchSubView(subview) {
            const btnGraph = document.getElementById('subview-graphical');
            const btnJson = document.getElementById('subview-json');
            const viewGraph = document.getElementById('sub-view-graphical');
            const viewJson = document.getElementById('sub-view-json');
            
            // Remove active from all buttons
            btnGraph.classList.remove('active');
            btnJson.classList.remove('active');
            
            // Hide all views
            viewGraph.style.display = 'none';
            viewJson.style.display = 'none';
            
            if(subview === 'graphical') {
                btnGraph.classList.add('active');
                viewGraph.style.display = 'block';
            } else if(subview === 'json') {
                btnJson.classList.add('active');
                viewJson.style.display = 'flex';
                updateJsonView();
            }
        }
        
        function updateLayoutJsonView() {
            const q = activeData[activeIndex];
            if (!q) return;
            
            // Use shared generateLayoutJson function
            const layoutData = generateLayoutJson(q);
            
            const textarea = document.getElementById('layout-json-textarea');
            if (textarea) {
                textarea.value = JSON.stringify(layoutData, null, 2);
            }
        }
        
        function getBlankStyle(text, options) {
            if (!text || !text.includes('__')) return '';
            let optionsToMeasure = options || [];
            if (!optionsToMeasure || optionsToMeasure.length === 0) {
                const match = text.match(/\(([^)]+)\)/); 
                if (match && match[1].includes('/')) { optionsToMeasure = match[1].split('/'); }
            }
            let width = '80px'; 
            if (optionsToMeasure && optionsToMeasure.length > 0) {
                let longest = 0;
                optionsToMeasure.forEach(opt => {
                    const txt = typeof opt === 'string' ? opt : (opt.text || '');
                    if (txt.length > longest) longest = txt.length;
                });
                const calcWidth = Math.max(80, (longest * 10 * 1.2)); 
                width = `${Math.round(calcWidth)}px`;
            }
            return width; 
        }
        // Helper function to render LaTeX math using KaTeX
        // Supports $...$ for inline and $$...$$ for display math
        function renderLatexMath(text) {
            if (!text || typeof katex === 'undefined') return text;
            
            // Render display math first ($$...$$)
            text = text.replace(/\$\$([^$]+)\$\$/g, (match, math) => {
                try {
                    return katex.renderToString(math.trim(), { displayMode: true, throwOnError: false });
                } catch (e) {
                    console.warn('KaTeX display error:', e);
                    return match;
                }
            });
            
            // Render inline math ($...$) - be careful not to match $$
            text = text.replace(/\$([^$]+)\$/g, (match, math) => {
                try {
                    return katex.renderToString(math.trim(), { displayMode: false, throwOnError: false });
                } catch (e) {
                    console.warn('KaTeX inline error:', e);
                    return match;
                }
            });
            
            return text;
        }
        
        // Helper function to render Markdown using marked.js
        function renderMarkdown(text) {
            if (!text || typeof marked === 'undefined') return text;
            
            try {
                // Configure marked for inline rendering (no wrapping <p> tags for simple text)
                marked.setOptions({
                    breaks: true,  // Convert \n to <br>
                    gfm: true      // GitHub Flavored Markdown
                });
                
                // Use parseInline for text that shouldn't be wrapped in <p>
                return marked.parseInline(text);
            } catch (e) {
                console.warn('Marked error:', e);
                return text;
            }
        }
        
        // v4.8: formatForPrint handles image tags with embedded dimensions [[image:id|height:H|width:W]]
        // Also supports Markdown and LaTeX math ($...$ and $$...$$)
        // Custom tags [[image:...]] and [[gap...]] are protected from Markdown/LaTeX processing
        // Images are wrapped in resizable containers for drag-to-resize in preview
        function formatForPrint(text, options) {
            if(!text) return '';
            let result = text;
            
            // Step 1: Handle legacy __ blanks FIRST (before any placeholders)
            // This must happen before we create placeholders to avoid conflicts
            if(result.includes('__') && !result.includes('[[')) {
                const w = getBlankStyle(text, options);
                result = result.replace(/_{2,}/g, `<span style="display:inline-block; border-bottom:1px solid #000; min-width:${w}; margin:0 4px;">&nbsp;</span>`);
            }
            
            // Step 2: Protect custom tokens with Unicode placeholders (won't be affected by Markdown/LaTeX)
            // Using Unicode private-use characters as delimiters: \uE000 and \uE001
            const imagePlaceholders = [];
            const gapPlaceholders = [];
            
            // Handle image tokens [[image:id]] or [[image:id|height:H|width:W]]
            result = result.replace(/\[\[image:([^\]]+)\]\]/g, (match, tagContent) => {
                const parsed = parseImageTag(tagContent);
                const imageId = parsed.id;
                
                let replacement;
                if (uploadedImages[imageId]) {
                    let imgStyle = '';
                    if (parsed.width) imgStyle += `width:${parsed.width}px;`;
                    if (parsed.height) imgStyle += `height:${parsed.height}px;`;
                    if (!parsed.width && !parsed.height) imgStyle = 'max-width:100%; max-height:200px;';
                    
                    const tooltipText = (parsed.width && parsed.height) 
                        ? `${parsed.width} Ã— ${parsed.height}` 
                        : 'Drag to resize';
                    
                    replacement = `<div class="p-asset-resizable" data-tag="${tagContent}">
                        <img src="${uploadedImages[imageId]}" alt="${imageId}" style="${imgStyle}">
                        <div class="resize-handle resize-handle-se" onmousedown="initImageResize(event, 'se', this.parentElement)"></div>
                        <div class="resize-handle resize-handle-e" onmousedown="initImageResize(event, 'e', this.parentElement)"></div>
                        <div class="resize-handle resize-handle-s" onmousedown="initImageResize(event, 's', this.parentElement)"></div>
                        <div class="size-tooltip">${tooltipText}</div>
                        <button class="reset-size-btn" onclick="resetImageSize(event, '${imageId}')" title="Reset to default size">Ã—</button>
                    </div>`;
                } else {
                    replacement = `<div class="p-asset-placeholder">ðŸ“· Image: ${imageId}</div>`;
                }
                
                const placeholder = `\uE000IMG${imagePlaceholders.length}\uE001`;
                imagePlaceholders.push(replacement);
                return placeholder;
            });
            
            // Handle [[gap]] or [[gap|width:<integer>]] placeholders for FIB
            result = result.replace(/\[\[gap(?:\|width:(\d+))?\]\]/g, (match, widthParam) => {
                const width = widthParam ? `${widthParam}px` : '60px';
                const replacement = `<span style="display:inline-block; border-bottom:2px solid #000; min-width:${width}; margin:0 4px;">&nbsp;</span>`;
                const placeholder = `\uE000GAP${gapPlaceholders.length}\uE001`;
                gapPlaceholders.push(replacement);
                return placeholder;
            });
            
            // Step 3: Render LaTeX math (before Markdown to preserve math formatting)
            result = renderLatexMath(result);
            
            // Step 4: Render Markdown
            result = renderMarkdown(result);
            
            // Step 5: Restore placeholders (custom tags are now safely rendered)
            imagePlaceholders.forEach((html, i) => {
                result = result.replace(`\uE000IMG${i}\uE001`, html);
            });
            gapPlaceholders.forEach((html, i) => {
                result = result.replace(`\uE000GAP${i}\uE001`, html);
            });
            
            return result;
        }

        function renderPreview(q, idx) {
            const container = document.getElementById('a4-content');
            const data = q.data || {};
            const meta = q.metadata || {};
            const solution = q.solution || {};
            const qType = q.type || 'SUBJECTIVE';
            
            // Get layout configuration and apply theme to A4 container
            const layoutConfig = getLayoutConfig(q);
            const theme = layoutConfig.theme;
            container.style.fontFamily = theme.font_family;
            container.style.fontSize = theme.base_font_size;
            container.style.lineHeight = theme.line_height;
            
            // Helper to render custom tokens and rich text (Markdown + LaTeX)
            // Handles [[image:id]], [[gap]], and supports $...$ / $$...$$ math and **bold** *italic*
            // Custom tokens are protected from Markdown/LaTeX processing using Unicode placeholders
            const renderImageTokens = (text) => {
                if (!text) return '';
                let result = text;
                
                // Step 1: Protect custom tokens with Unicode placeholders (\uE000...\uE001)
                const imagePlaceholders = [];
                const gapPlaceholders = [];
                
                // Handle [[image:id]] or [[image:id|height:H|width:W]]
                result = result.replace(/\[\[image:([^\]]+)\]\]/g, (match, tagContent) => {
                    const parsed = parseImageTag(tagContent);
                    const imageId = parsed.id;
                    
                    let replacement;
                    if (uploadedImages[imageId]) {
                        let imgStyle = '';
                        if (parsed.width) imgStyle += `width:${parsed.width}px;`;
                        if (parsed.height) imgStyle += `height:${parsed.height}px;`;
                        if (!parsed.width && !parsed.height) imgStyle = 'max-width:100%; max-height:150px;';
                        
                        const tooltipText = (parsed.width && parsed.height) 
                            ? `${parsed.width} Ã— ${parsed.height}` 
                            : 'Drag to resize';
                        
                        replacement = `<div class="p-asset-resizable" data-tag="${tagContent}">
                            <img src="${uploadedImages[imageId]}" alt="${imageId}" style="${imgStyle}">
                            <div class="resize-handle resize-handle-se" onmousedown="initImageResize(event, 'se', this.parentElement)"></div>
                            <div class="resize-handle resize-handle-e" onmousedown="initImageResize(event, 'e', this.parentElement)"></div>
                            <div class="resize-handle resize-handle-s" onmousedown="initImageResize(event, 's', this.parentElement)"></div>
                            <div class="size-tooltip">${tooltipText}</div>
                            <button class="reset-size-btn" onclick="resetImageSize(event, '${imageId}')" title="Reset to default size">Ã—</button>
                        </div>`;
                    } else {
                        replacement = `<div class="p-asset-placeholder">ðŸ“· Image: ${imageId}</div>`;
                    }
                    
                    const placeholder = `\uE000RIMG${imagePlaceholders.length}\uE001`;
                    imagePlaceholders.push(replacement);
                    return placeholder;
                });
                
                // Handle [[gap]] or [[gap|width:<integer>]]
                result = result.replace(/\[\[gap(?:\|width:(\d+))?\]\]/g, (match, widthParam) => {
                    const width = widthParam ? `${widthParam}px` : '60px';
                    const replacement = `<span style="display:inline-block; border-bottom:2px solid #000; min-width:${width}; margin:0 4px;">&nbsp;</span>`;
                    const placeholder = `\uE000RGAP${gapPlaceholders.length}\uE001`;
                    gapPlaceholders.push(replacement);
                    return placeholder;
                });
                
                // Step 2: Render LaTeX math
                result = renderLatexMath(result);
                
                // Step 3: Render Markdown
                result = renderMarkdown(result);
                
                // Step 4: Restore placeholders
                imagePlaceholders.forEach((html, i) => {
                    result = result.replace(`\uE000RIMG${i}\uE001`, html);
                });
                gapPlaceholders.forEach((html, i) => {
                    result = result.replace(`\uE000RGAP${i}\uE001`, html);
                });
                
                return result;
            };
            
            // Main content - for COMPOSITE it's common_content, others use content
            const mainContent = data.common_content || data.content || '';
            let promptHtml = `<div class="p-section-stack">
                    <div class="p-section-text"><span class="p-q-num">${q.id || idx + 1}.</span> ${formatForPrint(mainContent)}</div>
                </div>`;
            
            // Stimulus section - not used in v4.0, content is inline
            let stimHtml = '';
            
            // Word bank for FIB type - render below content
            let wordBankHtml = '';
            if (qType === 'FIB' && data.options_pool && data.options_pool.length > 0) {
                const wordItems = data.options_pool.map(word => `<span class="p-word-bank-item">${word}</span>`).join('');
                wordBankHtml = `<div class="p-word-bank">${wordItems}</div>`;
            }
            
            // Pairs for MATCH type
            if (qType === 'MATCH' && data.pairs && data.pairs.length > 0) {
                const leftItems = data.pairs.map((p, i) => 
                    `<div class="p-pairs-item"><span class="p-pairs-item-id">${i + 1}.</span>${renderImageTokens(p.left)}</div>`
                    ).join('');
                const rightItems = data.pairs.map((p, i) => 
                    `<div class="p-pairs-item"><span class="p-pairs-item-id">${String.fromCharCode(65 + i)}.</span>${renderImageTokens(p.right)}</div>`
                    ).join('');
                stimHtml += `
                        <div class="p-pairs-wrapper">
                            <div class="p-pairs-container">
                                <div class="p-pairs-column">
                                    <div class="p-pairs-header">Column A</div>
                                    ${leftItems}
                                </div>
                                <div class="p-pairs-column">
                                    <div class="p-pairs-header">Column B</div>
                                    ${rightItems}
                                </div>
                            </div>
                        </div>`;
                }
                
            // Options section for MCQ type
            let optionsHtml = '';
            if(qType === 'MCQ' && data.options && data.options.length > 0) {
                // Check for options_layout setting (default to horizontal)
                const optLayout = data.style?.options_layout || 'horizontal';
                const isOptHorizontal = optLayout === 'horizontal';
                const optItems = data.options.map((opt, k) => {
                    const optText = opt.text || '';
                    // Get option ID - use getIdDisplayLabel for consistent extraction
                    const rawOptId = opt.opt_id || opt.id || String.fromCharCode(65 + k); // Default to A, B, C, D...
                    const optId = getIdDisplayLabel(rawOptId);
                    return `<div class="p-option-item" style="${isOptHorizontal ? '' : 'margin-bottom:4px;'}">(${optId}) ${renderImageTokens(optText)}</div>`;
                    }).join('');
                // Wrap in flex container with appropriate direction
                optionsHtml = `<div class="p-options" style="display:flex; ${isOptHorizontal ? 'flex-wrap:wrap; gap:1rem;' : 'flex-direction:column;'}">${optItems}</div>`;
            }
            
            // TABLE type rendering (v4.6 - uses data.table with header and rows)
            let tableHtml = '';
            if(qType === 'TABLE' && data.table && data.table.rows) {
                const tableStyle = data.style || {};
                // v4.6: table_grid_lines controls grid line visibility
                const gridLines = tableStyle.table_grid_lines || 'all';
                // v4.6: hide_header is boolean
                const hideHeader = tableStyle.hide_header === true;
                // v4.9: column_widths for custom column sizing
                const columnWidths = tableStyle.column_widths || [];
                
                const tableData = data.table;
                const header = tableData.header || [];
                const rows = tableData.rows || [];
                const numRows = rows.length;
                const numCols = Math.max(header.length, rows[0]?.length || 0);
                
                // Helper to get cell border style based on grid lines setting and position
                function getCellBorderStyle(gridLines, isFirstCol, isLastCol, isFirstRow, isLastRow) {
                    const borderColor = '#d1d5db';
                    switch(gridLines) {
                        case 'none':
                            // No internal borders, but keep outer edges
                            return `border: none; ${isFirstCol ? `border-left: 1px solid ${borderColor};` : ''} ${isLastCol ? `border-right: 1px solid ${borderColor};` : ''} ${isFirstRow ? `border-top: 1px solid ${borderColor};` : ''} ${isLastRow ? `border-bottom: 1px solid ${borderColor};` : ''}`;
                        case 'horizontal':
                            // Horizontal lines only + left/right outer edges
                            return `border-top: 1px solid ${borderColor}; border-bottom: 1px solid ${borderColor}; border-left: ${isFirstCol ? `1px solid ${borderColor}` : 'none'}; border-right: ${isLastCol ? `1px solid ${borderColor}` : 'none'};`;
                        case 'vertical':
                            // Vertical lines only + top/bottom outer edges
                            return `border-left: 1px solid ${borderColor}; border-right: 1px solid ${borderColor}; border-top: ${isFirstRow ? `1px solid ${borderColor}` : 'none'}; border-bottom: ${isLastRow ? `1px solid ${borderColor}` : 'none'};`;
                        case 'all':
                        default:
                            return '';
                    }
                }
                
                // v4.9: Build colgroup for column widths
                let colgroupHtml = '';
                if (columnWidths.length > 0) {
                    const colItems = [];
                    for (let c = 0; c < numCols; c++) {
                        const colWidth = columnWidths[c] || '';
                        colItems.push(`<col ${colWidth ? `style="width:${colWidth}"` : ''}>`);
                    }
                    colgroupHtml = `<colgroup>${colItems.join('')}</colgroup>`;
                }
                
                // Build table header row (only if header exists and not hidden)
                let theadHtml = '';
                if (header.length > 0 && !hideHeader) {
                    let headerCellsHtml = header.map((cell, colIdx) => {
                        const isFirstCol = colIdx === 0;
                        const isLastCol = colIdx === numCols - 1;
                        const cellStyle = getCellBorderStyle(gridLines, isFirstCol, isLastCol, true, false);
                        return `<th style="${cellStyle}">${renderImageTokens(cell || '')}</th>`;
                    }).join('');
                    theadHtml = `<thead><tr>${headerCellsHtml}</tr></thead>`;
                }
                
                // Build table rows
                const tableRows = rows.map((row, rowIdx) => {
                    const isFirstRow = (header.length === 0 || hideHeader) && rowIdx === 0;
                    const isLastRow = rowIdx === numRows - 1;
                    
                    const rowCells = (row || []).map((cell, colIdx) => {
                        const isFirstCol = colIdx === 0;
                        const isLastCol = colIdx === (row.length - 1);
                        const cellStyle = getCellBorderStyle(gridLines, isFirstCol, isLastCol, isFirstRow, isLastRow);
                        return `<td style="${cellStyle}">${renderImageTokens(cell || '')}</td>`;
                    }).join('');
                    
                    return `<tr>${rowCells}</tr>`;
                }).join('');
                
                // Table style - use border-collapse: collapse
                const tableBorderStyle = 'border-collapse: collapse;';
                
                tableHtml = `
                    <div class="p-table-container">
                        <table class="p-table-grid" style="${tableBorderStyle}">
                            ${colgroupHtml}
                            ${theadHtml}
                            <tbody>
                                ${tableRows}
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            // Sub-questions section for COMPOSITE type
            let subHtml = '';
            let sharedWordBankHtml = '';
            if(qType === 'COMPOSITE' && data.sub_questions && data.sub_questions.length > 0) {
                // Check if all FIB sub-questions share the same options_pool
                const fibSubQuestions = data.sub_questions.filter(sq => sq.type === 'FIB' && sq.data?.options_pool?.length > 0);
                let hasSharedOptionsPool = false;
                let sharedOptionsPool = [];
                
                if (fibSubQuestions.length > 1) {
                    // Check if all FIB sub-questions have the same options_pool
                    const firstPool = JSON.stringify(fibSubQuestions[0].data.options_pool.slice().sort());
                    hasSharedOptionsPool = fibSubQuestions.every(sq => 
                        JSON.stringify(sq.data.options_pool.slice().sort()) === firstPool
                    );
                    if (hasSharedOptionsPool) {
                        sharedOptionsPool = fibSubQuestions[0].data.options_pool;
                    }
                }
                
                // Render shared word bank once below all sub-questions if applicable
                if (hasSharedOptionsPool && sharedOptionsPool.length > 0) {
                    const wordItems = sharedOptionsPool.map(word => `<span class="p-word-bank-item">${word}</span>`).join('');
                    sharedWordBankHtml = `<div class="p-word-bank">${wordItems}</div>`;
                }
                
                // Use style.sub_questions_layout, default to vertical
                const sectionSubLayout = data.style?.sub_questions_layout || 'vertical';
                const subs = data.sub_questions.map((sq, i) => {
                    const label = sq.id ? getIdDisplayLabel(sq.id) : String.fromCharCode(97 + i);
                    const sqData = sq.data || {};
                    const sqContent = sqData.content || '';
                    
                    // Sub-question options for MCQ
                    let optHtml = '';
                    if(sq.type === 'MCQ' && sqData.options && sqData.options.length > 0) {
                        // v4.1: style is always inside data object
                        const optLayout = sqData.style?.options_layout || 'horizontal';
                        const isOptHorizontal = optLayout === 'horizontal';
                        const optItems = sqData.options.map((o, k) => {
                            const txt = o.text || '';
                            // Get option ID - use getIdDisplayLabel for consistent extraction
                            const rawOptId = o.opt_id || o.id || String.fromCharCode(97 + k);
                            const optId = getIdDisplayLabel(rawOptId);
                            // Use div for proper block-level content support (images)
                            return `<div class="p-sq-option" style="display:flex; align-items:flex-start; gap:4px; ${isOptHorizontal ? '' : 'margin-bottom:4px;'}">
                                <span style="white-space:nowrap;">(${optId})</span>
                                <div>${renderImageTokens(txt)}</div>
                        </div>`;
                        }).join('');
                        // Wrap in flex container with appropriate direction
                        optHtml = `<div style="display:flex; ${isOptHorizontal ? 'flex-wrap:wrap; gap:1rem;' : 'flex-direction:column;'}">${optItems}</div>`;
                    }
                    
                    // FIB options_pool as word bank - only show if NOT using shared pool
                    let sqWordBank = '';
                    if (sq.type === 'FIB' && sqData.options_pool && sqData.options_pool.length > 0 && !hasSharedOptionsPool) {
                        const sqWordItems = sqData.options_pool.map(word => `<span class="p-word-bank-item">${word}</span>`).join('');
                        sqWordBank = `<div class="p-word-bank" style="margin-top:8px; font-size:9pt;">${sqWordItems}</div>`;
                    }
                    
                    // TABLE type for sub-questions (v4.6 - uses data.table with header and rows)
                    let sqTableHtml = '';
                    if (sq.type === 'TABLE' && sqData.table && sqData.table.rows) {
                        const sqTableStyle = sqData.style || {};
                        const sqGridLines = sqTableStyle.table_grid_lines || 'all';
                        const sqHideHeader = sqTableStyle.hide_header === true;
                        
                        const sqTableData = sqData.table;
                        const sqHeader = sqTableData.header || [];
                        const sqRows = sqTableData.rows || [];
                        const sqNumRows = sqRows.length;
                        const sqNumCols = Math.max(sqHeader.length, sqRows[0]?.length || 0);
                        
                        // Helper to get cell border style based on grid lines setting and position
                        function getSqCellBorderStyle(gridLines, isFirstCol, isLastCol, isFirstRow, isLastRow) {
                            const borderColor = '#d1d5db';
                            switch(gridLines) {
                                case 'none':
                                    return `border: none; ${isFirstCol ? `border-left: 1px solid ${borderColor};` : ''} ${isLastCol ? `border-right: 1px solid ${borderColor};` : ''} ${isFirstRow ? `border-top: 1px solid ${borderColor};` : ''} ${isLastRow ? `border-bottom: 1px solid ${borderColor};` : ''}`;
                                case 'horizontal':
                                    return `border-top: 1px solid ${borderColor}; border-bottom: 1px solid ${borderColor}; border-left: ${isFirstCol ? `1px solid ${borderColor}` : 'none'}; border-right: ${isLastCol ? `1px solid ${borderColor}` : 'none'};`;
                                case 'vertical':
                                    return `border-left: 1px solid ${borderColor}; border-right: 1px solid ${borderColor}; border-top: ${isFirstRow ? `1px solid ${borderColor}` : 'none'}; border-bottom: ${isLastRow ? `1px solid ${borderColor}` : 'none'};`;
                                case 'all':
                                default: return '';
                            }
                        }
                        
                        // Build header row (only if header exists and not hidden)
                        let sqTheadHtml = '';
                        if (sqHeader.length > 0 && !sqHideHeader) {
                            let sqHeaderCellsHtml = sqHeader.map((cell, colIdx) => {
                                const isFirstCol = colIdx === 0;
                                const isLastCol = colIdx === sqNumCols - 1;
                                const cellStyle = getSqCellBorderStyle(sqGridLines, isFirstCol, isLastCol, true, false);
                                return `<th style="font-size:0.85em; padding:4px; ${cellStyle}">${renderImageTokens(cell || '')}</th>`;
                        }).join('');
                            sqTheadHtml = `<thead><tr>${sqHeaderCellsHtml}</tr></thead>`;
                        }
                        
                        const sqTableRows = sqRows.map((row, rowIdx) => {
                            const isFirstRow = (sqHeader.length === 0 || sqHideHeader) && rowIdx === 0;
                            const isLastRow = rowIdx === sqNumRows - 1;
                            
                            const sqRowCells = (row || []).map((cell, colIdx) => {
                                const isFirstCol = colIdx === 0;
                                const isLastCol = colIdx === (row.length - 1);
                                const cellStyle = getSqCellBorderStyle(sqGridLines, isFirstCol, isLastCol, isFirstRow, isLastRow);
                                return `<td style="padding:4px; ${cellStyle}">${renderImageTokens(cell || '')}</td>`;
                            }).join('');
                            
                            return `<tr>${sqRowCells}</tr>`;
                        }).join('');
                        
                        sqTableHtml = `
                            <div class="p-table-container" style="margin-top:8px;">
                                <table class="p-table-grid" style="font-size:0.9em; border-collapse: collapse;">
                                    ${sqTheadHtml}
                                    <tbody>${sqTableRows}</tbody>
                                </table>
                            </div>
                        `;
                    }
                    
                    // Content layout for individual sub-questions
                    const contentHtml = `
                            <div style="width:100%">
                            <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:0.5rem;">
                                <div style="flex:1;">${formatForPrint(sqContent) || '<em style="color:#999;">No text</em>'}</div>
                            </div>
                                ${optHtml ? `<div style="margin-top:4px; font-size:10pt;">${optHtml}</div>` : ''}
                                ${sqTableHtml}
                                ${sqWordBank}
                            </div>`;
                    
                    return `<div class="p-sub-item"><span class="p-sub-label">${label}.</span>${contentHtml}</div>`;
                }).join('');
                
                // Apply layout based on mode: vertical (stack) or horizontal (2 cols)
                subHtml = sectionSubLayout === 'horizontal' 
                    ? `<div class="p-sub-grid">${subs}</div>` 
                    : `<div>${subs}</div>`;
            }
            
            const points = meta.marks || '1';
            const marksText = `[${points}]`;
            
            // Render content first to check if it needs multiple pages
            // For COMPOSITE: sharedWordBankHtml renders below content but above sub-questions
            container.innerHTML = `<div class="p-q-block">
                <div class="p-q-header">
                    <div class="p-q-content">${promptHtml}</div>
                    <div class="p-q-marks">${marksText}</div>
                </div>
                ${stimHtml}${optionsHtml}${tableHtml}${wordBankHtml}${sharedWordBankHtml}${subHtml}
            </div>`;
        }

        // Initialize with default view
        switchWorkflow('import');

    </script>
</body>
</html>
